<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Literate Programming using SMUG</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="title" content="Literate Programming using SMUG"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-03-23T10:54-0700"/>
<meta name="author" content="Drew Crampsie"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Literate Programming using SMUG</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Org Literate</a>
<ul>
<li><a href="#sec-1-1">1.1 The Source Blocks</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1 Header Arguments</a></li>
<li><a href="#sec-1-1-2">1.1.2 syntax highlighting</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-2">2 Tangle :: take the source of source and tangle it into source code</a>
<ul>
<li><a href="#sec-2-1">2.1 To a file</a></li>
</ul>
</li>
<li><a href="#sec-3">3 Noweb :: reference named blocks of code</a></li>
<li><a href="#sec-4">4 Test test test</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Org Literate</h2>
<div class="outline-text-2" id="text-1">


<p>
The literate programming source files currently use org-mode as the
default syntax.
</p>
<p>
Emacs supports this using org-babel, and where possible we use the
same thing. 
</p>

</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> The Source Blocks</h3>
<div class="outline-text-3" id="text-1-1">


<p>
The source blocks are parsed as part of <a href="file:///home/drewc/me/src/smug/parser/org-syntax.html#Blocks">Org Blocks</a>.
</p>
<p>
As this is the first source-block in this file, we can see it via this:
</p>



<pre class="example">(first (smug/literate/tangle:source-blocks 
        (merge-pathnames #P"quicklisp/local-projects/smug/literate/literate.org"
                         (user-homedir-pathname))))
</pre>


<p>
That returns the following:
</p>



<pre class="example">#&lt;SMUG/PARSER/ORG::SOURCE-BLOCK 
    SMUG/PARSER/ORG::WHITESPACE-PREFIX: NIL
    SMUG/PARSER/ORG::WHITESPACE-POSTFIX: SMUG/PARSER/ORG::|#&lt;unbound&gt;|
    SMUG/PARSER/ORG::KEYWORDS: NIL
    SMUG/PARSER/ORG::NAME: "SRC"
    SMUG/PARSER/ORG::PARAMETERS: "lisp :tangle \"/tmp/first-org-source-block.lisp\""
    SMUG/PARSER/ORG::CONTENTS: ("  (first (smug/literate/tangle:source-blocks "
                                "          (merge-pathnames #P\"quicklisp/local-projects/smug/literate/literate.org\""
                                "                           (user-homedir-pathname))))")
    SMUG/PARSER/ORG::LANGUAGE: "lisp"
    SMUG/PARSER/ORG::SWITCHES: NIL
    SMUG/PARSER/ORG::ARGUMENTS: ":tangle \"/tmp/first-org-source-block.lisp\""&gt;
</pre>



</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> Header Arguments</h4>
<div class="outline-text-4" id="text-1-1-1">

<ul>
<li id="sec-1-1-1-1">padline :: control padded lines around blocks<br/>

<blockquote>

<p>Control in insertion of padding lines around code block bodies in
tangled code files.  The default value is `yes' which results in
insertion of newlines before and after each tangled code block.  The
following arguments are accepted.
</p>
<ul>
<li>`yes' Insert newlines before and after each code block body in
     tangled code files.

</li>
<li>`no' Do not insert any newline padding in tangled output.
</li>
</ul>


<p>
&ndash; <i>&lt;info:org#padline&gt;</i>
</p>
</blockquote>


</li>
</ul>
</div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> syntax highlighting</h4>
<div class="outline-text-4" id="text-1-1-2">




<pre class="example">(setq org-src-fontify-natively t)
</pre>


</div>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Tangle :: take the source of source and tangle it into source code</h2>
<div class="outline-text-2" id="text-2">



<blockquote>

<p>Creating pure source code files by extracting code from source blocks is
referred to as "tangling"&ndash;a term adopted from the literate programming
community.  During "tangling" of code blocks their bodies are expanded
using `org-babel-expand-src-block' which can expand both variable and
"noweb" style references  (see *note Noweb reference syntax::).
</p>
<p>
Header arguments
&hellip;&hellip;&hellip;&hellip;&hellip;.
</p>
<p>
`:tangle no'
     The default.  The code block is not included in the tangled output.
</p>
<p>
`:tangle yes'
     Include the code block in the tangled output.  The output file
     name is the name of the org file with the extension `.org'
     replaced by the extension for the block language.
</p>
<p>
`:tangle filename'
     Include the code block in the tangled output to file `filename'.
</p>
<p>
&ndash; <i>&lt;info:org#Extracting source code&gt;</i>
</p>
</blockquote>



</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> To a file</h3>
<div class="outline-text-3" id="text-2-1">


<p>
In the example of <a href="#sec-1-1">The Source Blocks</a>, we can see that code block is tangled to a file.
</p>



<pre class="example">#+BEGIN_SRC lisp :tangle "/tmp/first-org-source-block.lisp" :padline no
  (first (smug/literate/tangle:source-blocks 
           (merge-pathnames #P"quicklisp/local-projects/smug/literate/literate.org"
                            (user-homedir-pathname))))
#+END_SRC
</pre>


<p>
So, when this file is tangled, the <code>#P\"/tmp/first-org-source-block.lisp\"\</code>
</p>


<pre class="example">(smug/literate/tangle:tangle-file 
 (merge-pathnames #P"quicklisp/local-projects/smug/literate/literate.org"
                  (user-homedir-pathname)))
</pre>



<pre class="example">cat /tmp/first-org-source-block.lisp
</pre>



</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Noweb :: reference named blocks of code</h2>
<div class="outline-text-2" id="text-3">


<blockquote>

<p>The "noweb" (see `<a href="http://www.cs.tufts.edu/~nr/noweb/">http://www.cs.tufts.edu/~nr/noweb/</a>') Literate
Programming system allows named blocks of code to be referenced by
using the familiar Noweb syntax:
</p>
<p>
     <a name="code-block-name" class="target">code-block-name</a> 
</p>
<p>
&ndash; <i>&lt;info:org#Noweb reference syntax&gt;</i>
</p>
</blockquote>


<p>
In this file, we have a code block with a name.
</p>



<pre class="example">#+NAME: tangle-this-file
#+BEGIN_SRC lisp
  (smug/literate/tangle:tangle-file 
   (merge-pathnames #P"quicklisp/local-projects/smug/literate/literate.org"
                    (user-homedir-pathname)))          
#+END_SRC  
</pre>


<p>
If we make another code block with the header argument <code>:noweb yes</code>,
we can merge other code blocks inside it.
</p>



<pre class="example">;;;; This is a file, a .lisp file, with some comments In reality it is
;;;; to test the noweb reference So, here we reference a code block :

;;;; (smug/literate/tangle:tangle-file 
;;;;  (merge-pathnames #P"quicklisp/local-projects/smug/literate/literate.org"
;;;;                   (user-homedir-pathname))) this is the end

;;;; This is also the codeblock, but this time a reference without the
;;;; starting ";;;;"

(smug/literate/tangle:tangle-file 
 (merge-pathnames #P"quicklisp/local-projects/smug/literate/literate.org"
                  (user-homedir-pathname))) ;; my only friend, the end
</pre>

















</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Test test test</h2>
<div class="outline-text-2" id="text-4">





<pre class="example">;;;; diff.lisp - producing unified style diffs from Common Lisp

;;; The diffs generated by this package may not match the diffs
;;; generated by GNU diff (or other diff programs of which I have
;;; not heard).  However, the diffs produced should still apply
;;; cleanly with `patch' or something similar.  If you find files
;;; where this does not hold true, please contact me.
;;;
;;; Differences between line ending conventions are pretty much
;;; ignored in the current implementation, since READ-LINE is used
;;; to snarf the lines from the file.  GNU diff indicates whether
;;; or not the last line in the file ended in a newline; the last
;;; line of our diffs always end in newlines, which may or may not
;;; be acceptable to some people.
;;;
;;; No effort has been made to optimize for speed.  Nonetheless,
;;; the implementation is probably "fast enough", since generating
;;; diffs is not really a speed-critical task.
;;;
;;; Compared to GNU diff, the set of options is pretty small.

(defpackage :smug/literate/diff
  (:use :cl)
  (:export #:*diff-context-lines*
           #:generate-diff
           #:generate-seq-diff
           #:unified-diff #:context-diff

           #:apply-seq-window
           #:apply-seq-diff
           #:apply-seq-patch
           #:apply-patch

           #:render-diff
           #:render-diff-window
           #:format-diff
           #:format-diff-string

           #:diff
           #:original-pathname
           #:modified-pathname
           #:diff-window-class
           #:diff-windows

           #:diff-window
           #:original-start-line
           #:original-length
           #:modified-start-line
           #:modified-length
           #:window-chunks

           #:chunk-kind
           #:chunk-lines

           #:compute-raw-diff
           #:compute-raw-seq-diff
           #:common-diff-region
           #:modified-diff-region
           #:original-start
           #:original-length
           #:modified-start
           #:modified-length))

(in-package :smug/literate/diff)
(declaim (optimize (debug 3)))

** 
;;; interning arbitrary objects for equality

;;; We've made this fairly general, but we really only use this
;;; machinery to intern strings.  I suppose we could have used CL:INTERN
;;; for this purpose, but I doubt the symbol implementations in a lot
;;; of Common Lisp implementations could handle our requirements.  Plus
;;; it's not clear that symbols are ever garbage-collected.

(defclass interner ()
  ((object-to-code-table :initarg :object-to-code-table
                         :reader object-to-code-table)
   (code-to-object-table :initarg :code-to-object-table
                         :accessor code-to-object-table)
   (last-code :initform 0 :type integer :accessor last-code)))

(defun make-interner (&amp;key (test #'equal))
  (let ((object-to-code-table (make-hash-table :test test))
        (code-to-object-table (make-array 128)))
    (make-instance 'interner :object-to-code-table object-to-code-table
                   :code-to-object-table code-to-object-table)))

(defun interned-object (interner code)
  (aref (code-to-object-table interner) code))

(defun intern-string (interner string)
  (multiple-value-bind (code presentp)
      (gethash string (object-to-code-table interner))
    (if presentp
        code                            ; string already exists
        (let ((object-code (last-code interner))
              (otc-table (object-to-code-table interner))
              (cto-table (code-to-object-table interner)))
          ;; grow table if necessary
          (when (= object-code (length cto-table))
            (let ((new-cto-table (make-array (* (length cto-table) 2))))
              (replace new-cto-table cto-table)
              (setf cto-table new-cto-table)
              (setf (code-to-object-table interner) new-cto-table)))
          (setf (gethash string otc-table) object-code
                (aref cto-table object-code) string)
          (incf (last-code interner))
          object-code))))

(defmacro do-stream-lines ((line-var stream-var &amp;optional result) &amp;body body)
  `(loop for ,line-var = (read-line ,stream-var nil nil)
         while ,line-var
         do ,@body
         finally (return ,result)))

(defmacro do-file-lines ((line-var pathname-var &amp;optional result) &amp;body body)
  (let ((stream-var (gensym)))
    `(with-open-file (,stream-var ,pathname-var :direction :input
                      :element-type 'character)
      (do-stream-lines (,line-var ,stream-var ,result)
        ,@body))))

(defun intern-files (&amp;rest files)
  (let ((interner (make-interner))
        (interned-files nil))
    (dolist (file files (values interner (nreverse interned-files)))
      (let ((interned-file nil))
        (do-file-lines (line file)
          (let ((code (intern-string interner line)))
            (push code interned-file)))
        (push (coerce (nreverse interned-file) 'simple-vector) interned-files)))))

(defun intern-seqs (&amp;rest seqs)
  (let ((interner (make-interner))
        (interned-seqs nil))
    (dolist (seq seqs (values interner (nreverse interned-seqs)))
      (let ((interned-seq nil))
        (loop :for line :in seq :do
           (let ((code (intern-string interner line)))
             (push code interned-seq)))
        (push (coerce (nreverse interned-seq) 'simple-vector) interned-seqs)))))

** 
;;; Computing longest common subsequences between two sequences whose
;;; elements compare equal via EQL.  The algorithm used here is based
;;; on _An O(NP) Sequence Comparison Algorithm_ by Sun Wu, Udi Manber,
;;; and Gene Meyers.

(defclass snake ()
  ((original-offset :accessor original-offset :initarg :original-offset)
   (modified-offset :accessor modified-offset :initarg :modified-offset)
   (length :accessor snake-length :initarg :length)
   (lcs :accessor lcs :initform nil)))

(defmethod print-object ((snake snake) stream)
  (print-unreadable-object (snake stream)
    (format stream "Snake ~A ~A ~A" 
            (original-offset snake)
            (modified-offset snake)
            (snake-length snake))))

(defun snake (lcs original modified k y)
  (let* ((x (- y k))
         (y y)
         (x-start x)
         (y-start y))
    (loop while (and (&lt; -1 x (length original))
                     (&lt; -1 y (length modified))
                     (eql (svref original x) (svref modified y)))
      do (incf x) (incf y))
    (let ((snake (make-instance 'snake
                                :original-offset x-start
                                :modified-offset y-start
                                :length (- y y-start))))
      (if (= y-start y)
          (setf (lcs snake) lcs)
          (setf (lcs snake) (cons snake lcs)))
      snake)))

(defun modified-end (snake)
  (+ (modified-offset snake) (snake-length snake)))

(defun compute-lcs* (original modified)
  (let* ((m (length original))
         (n (length modified))
         (fp (make-array (+ m n 3)
                         :initial-element (make-instance 'snake
                                                         :original-offset -1
                                                         :modified-offset -1
                                                         :length 0)))
         (delta (- n m)))
    ;; There ought to be a good way to let the lengths be arbitrary,
    ;; but right now, we're just going to enforce that the modified
    ;; always be longer and let the caller do the fixing if need be.
    (when (minusp delta)
      (error "Length of MODIFIED less than length of ORIGINAL."))
    (macrolet ((fpref (index)
                 `(svref fp (+ ,index m 1))))
      (flet ((do-snake (index)
               ;; ugh, FIXME
               (let ((snake (let ((lower-snake (fpref (1- index)))
                                  (upper-snake (fpref (1+ index))))
                              (if (&gt; (1+ (modified-end lower-snake))
                                     (modified-end upper-snake))
                                  (snake (lcs lower-snake)
                                         original modified index
                                         (1+ (modified-end lower-snake)))
                                  (snake (lcs upper-snake)
                                         original modified index
                                         (modified-end upper-snake))))))
                 (setf (fpref index) snake))))
        (do ((p 0 (1+ p)))
            ((= (modified-end (fpref delta)) n)
             ;; Add one last snake to easily detect EOF.
             (nreverse (cons (make-instance 'snake :original-offset m
                                            :modified-offset n
                                            :length 0)
                             (lcs (fpref delta)))))
          (loop for k from (- p) upto (1- delta)
                do (do-snake k))
          (loop for k from (+ delta p) downto (1+ delta)
                do (do-snake k))
          (do-snake delta))))))

(defun compute-lcs (original modified)
  (let* ((original-length (length original))
         (modified-length (length modified))
         (modified-longer-p (&gt; modified-length original-length))
         ;; The algorithm given in the paper only works when the
         ;; modified is at least as long as the original.  So we let
         ;; the algorithm follow that assumption and then fix it
         ;; at a later point.  The lcs between two originals is
         ;; always the same--but the *diff* between them will be
         ;; different depending on the ordering.
         (lcs (if modified-longer-p
                  (compute-lcs* original modified)
                  (compute-lcs* modified original))))
    (unless modified-longer-p
      ;; Go through and fix the lcs to have the right references.
      (dolist (snake lcs)
        (rotatef (original-offset snake) (modified-offset snake))))
    lcs))
** 
;;; actually producing diffs from longest common subsequences

(defclass diff-region ()
  ((original-start :initarg :original-start :reader original-start)
   (original-length :initarg :original-length :reader original-length)
   (modified-start :initarg :modified-start :reader modified-start)
   (modified-length :initarg :modified-length :reader modified-length)))

(defclass common-diff-region (diff-region) ())

(defclass modified-diff-region (diff-region) ())

(defmethod print-object ((diff-region diff-region) stream)
  (print-unreadable-object (diff-region stream)
    (format stream "~A src:~A/~A mod:~A/~A"
            (class-name (class-of diff-region))
            (original-start diff-region) (original-length diff-region)
            (modified-start diff-region) (modified-length diff-region))))

(defun convert-lcs-to-diff (lcs &amp;key (want-common t)
                                (original-start 0)
                                (modified-start 0))
  (let ((diff-regions nil))
    (loop
        (let ((snake (first lcs)))
          (when (or (&lt; original-start (original-offset snake))
                    (&lt; modified-start (modified-offset snake)))
            (push (make-instance 'modified-diff-region
                                 :original-start original-start
                                 :original-length (- (original-offset snake)
                                                   original-start)
                                 :modified-start modified-start
                                 :modified-length (- (modified-offset snake)
                                                   modified-start))
                  diff-regions))
          (when (zerop (snake-length snake))
            ;; Party's over, let's go home.
            (return-from convert-lcs-to-diff (nreverse diff-regions)))
          (setf original-start (original-offset snake)
                modified-start (modified-offset snake))
          (when want-common
            (push (make-instance 'common-diff-region
                                 :original-start original-start
                                 :original-length (snake-length snake)
                                 :modified-start modified-start
                                 :modified-length (snake-length snake))
                  diff-regions))
          (incf original-start (snake-length snake))
          (incf modified-start (snake-length snake))
          (pop lcs)))))

(defun compute-raw-diff (origin modified)
  (convert-lcs-to-diff (compute-lcs origin modified)))

(defun compute-raw-seq-diff (original-seq modified-seq)
  (multiple-value-bind (interner interned-seqs)
      (intern-seqs original-seq modified-seq)
    (declare (ignorable interner))
    (convert-lcs-to-diff (apply #'compute-lcs interned-seqs))))

** 
;;; producing diffs in "unified diff" format

(defparameter *diff-context-lines* 3
  "The number of lines of context to include for unified and context style
diffs.  The 'patch' program will have a hard time with less than two lines
of context; the default of three should be good enough for most situations.")

(defclass diff ()
  ((original-pathname :initarg :original-pathname :accessor original-pathname)
   (modified-pathname :initarg :modified-pathname :accessor modified-pathname)
   (window-class :initarg :window-class :reader diff-window-class)
   (windows :initform nil :accessor diff-windows)))

(defclass unified-diff (diff) ()
  (:default-initargs
   :window-class 'unified-diff-window))

(defclass context-diff (diff) ()
  (:default-initargs
   :window-class 'context-diff-window))

(defclass diff-generator ()
  ((interned-lines :initarg :interned-lines :reader interner)
   (original-lines :initarg :original-lines :reader original-lines)
   (modified-lines :initarg :modified-lines :reader modified-lines)
   (current-window :initform nil :accessor current-window)
   (diff :initarg :diff :reader diff)))

(defun original-line (context index)
  (let ((interner (interner context))
        (original-lines (original-lines context)))
    (interned-object interner (aref original-lines index))))

(defun modified-line (context index)
  (let ((interner (interner context))
        (modified-lines (modified-lines context)))
    (interned-object interner (aref modified-lines index))))

;;; Some other diff implementations call this a "hunk".
(defclass diff-window ()
  ((original-start-line :initarg :original-start-line
                        :accessor original-start-line)
   (modified-start-line :initarg :modified-start-line
                        :accessor modified-start-line)
   (original-length :initarg :original-length
                    :initform 0
                    :accessor original-length)
   (modified-length :initarg :modified-length
                    :initform 0
                    :accessor modified-length)
   (window-chunks :initform nil
                  :accessor window-chunks)))

(defun apply-seq-window (original-seq window &amp;key (offset 0))
  "Apply the edits encoded in WINDOW to the ORIGINAL-SEQ."
  (multiple-value-bind (interner interned-seqs)
      (apply #'intern-seqs original-seq
             (mapcar #'chunk-lines (window-chunks window)))
    (let ((index (original-start-line window))
          (result (coerce (first interned-seqs) 'list)))
      (flet ((ind () (+ index offset))
             (back (line) (interned-object interner line)))
        (loop
           for chunk in (window-chunks window)
           for lines in (mapcar (lambda (l) (coerce l 'list)) (cdr interned-seqs))
           do (case (chunk-kind chunk)
                (:common
                 (mapc (lambda (line)
                         (assert (eql line (nth (ind) result))
                                 (line result index)
                                 "window does not apply at ~d, ~s!=~s "
                                 (ind) (back line) (back (nth (ind) result)))
                         (incf index))
                       lines))
                ((:replace :delete)
                 (setf result
                       (append (subseq result 0 (ind))
                               (subseq result (+ (ind) (length lines)))))
                 (incf index  (length lines))
                 (decf offset (length lines)))
                ((:insert :create)
                 (setf result (append (subseq result 0 (ind))
                                      lines
                                      (subseq result (ind))))
                 (incf offset (length lines)))))
        (values (mapcar #'back result) offset)))))

(defun apply-seq-diff (original-seq diff)
  "Apply DIFF to the sequence ORIGINAL-SEQ."
  (apply #'values
    (reduce
     (lambda (accumulator window)
       (destructuring-bind (seq offset) accumulator
         (multiple-value-call #'list
           (apply-seq-window seq window :offset offset))))
     (diff-windows diff) :initial-value (list original-seq 0))))

(deftype chunk-kind () '(member :common :delete :replace :insert :create))

(defclass chunk ()
  ((kind :initarg :kind :reader chunk-kind :type chunk-kind)
   (lines :initarg :lines :reader chunk-lines :type list)))

(defun modified-chunk-p (chunk)
  (let ((kind (chunk-kind chunk)))
    (or (eq kind :insert) (eq kind :create))))

(defun original-chunk-p (chunk)
  (let ((kind (chunk-kind chunk)))
    (or (eq kind :delete) (eq kind :replace))))

(defmethod print-object ((object chunk) stream)
  (print-unreadable-object (object stream)
    (format stream "Chunk ~A / ~A" (chunk-kind object)
            (length (chunk-lines object)))))

(defclass unified-diff-window (diff-window) ())
(defclass context-diff-window (diff-window) ())

(defun create-window (generator)
  (create-window-for-diff (diff generator)))

(defun create-window-for-diff (diff)
  (make-instance (diff-window-class diff)))

(defun original-window-length (window)
  (reduce #'+ (window-chunks window)
          :key #'(lambda (chunk)
                   (ecase (chunk-kind chunk)
                     ((:common :delete :replace) (length (chunk-lines chunk)))
                     ((:insert :create) 0)))
          :initial-value 0))

(defun modified-window-length (window)
  (reduce #'+ (window-chunks window)
          :key #'(lambda (chunk)
                   (ecase (chunk-kind chunk)
                     ((:common :insert :create) (length (chunk-lines chunk)))
                     ((:delete :replace) 0)))
          :initial-value 0))

(defun add-window (context window)
  (setf (window-chunks window) (nreverse (window-chunks window)))
  (push window (diff-windows (diff context)))
  (setf (current-window context) nil))

(defgeneric process-region (context region))

(defun last-region-p (context region)
  (and (= (length (original-lines context))
          (+ (original-start region) (original-length region)))
       (= (length (modified-lines context))
          (+ (modified-start region) (modified-length region)))))

(defmethod process-region ((context diff-generator)
                           (region common-diff-region))
  (when (current-window context)
    (do ((i 0 (1+ i))
         (common-lines nil))
        ;; I'm not entirely convinced that this is right, but the logic
        ;; embodied in this complicated expression can be summarized
        ;; as follows:
        ;;
        ;; * if this is the last region in the diff, then we should
        ;;   only add a few lines of context;
        ;; * if this is a "large" region, then we should only add a
        ;;   few lines of context
        ;; * otherwise, we have a "small" connecting region and we
        ;;   should attempt to add the entire thing.
        ((or (if (or (&gt; (original-length region)
                        (* *diff-context-lines* 2))
                     (last-region-p context region))
                 (= i *diff-context-lines*)
                 (= i (* *diff-context-lines* 2)))
             (= i (original-length region)))
         ;; Add the lines to the current window.
         (push (make-instance 'chunk
                              :kind :common
                              :lines (nreverse common-lines))
               (window-chunks (current-window context)))
         ;; If this is the last chunk of common lines to add, then we
         ;; need to reverse the chunks of lines in the window, add
         ;; the current window to the window list and null out the
         ;; current window.
         (when (&gt; (original-length region)
                  (* *diff-context-lines* 2))
           (add-window context (current-window context))))
      (push (original-line context (+ i (original-start region)))
            common-lines))))

(defmethod process-region ((context diff-generator)
                           (region modified-diff-region))
  (let ((window (current-window context)))
    (unless window
      ;; This is the ugly case, because there was some common region
      ;; which we don't know about, yet we have to add lines from said
      ;; region.  We do know, however, that the common region which
      ;; preceeded this one must have been longer than
      ;; *DIFF-CONTEXT-LINES* lines, or else the window would not
      ;; be NIL.  We therefore walk backwards from ourself, adding
      ;; common lines as we go, and then we add the lines we contribute.
      (do ((i 0 (1+ i))
           (new-window (create-window context))
           (common-lines nil))
          ((or (= i *diff-context-lines*)
               ;; Edge case of when the common region begins the file
               ;; and is quite small.
               (= 0 (- (original-start region) i)))
           (push (make-instance 'chunk
                                :kind :common
                                :lines common-lines)
                 (window-chunks new-window))
           ;; Make a note of where this window started for posterity.
           (setf (original-start-line new-window) (- (original-start region) i)
                 (modified-start-line new-window) (- (modified-start region) i))
           (setf (current-window context) new-window)
           (setf window new-window))
        (push (original-line context (- (original-start region) i 1))
              common-lines)))
    ;; Deletes come first.
    (when (plusp (original-length region))
      (loop for index from (original-start region)
            below (+ (original-start region) (original-length region))
            collect (original-line context index) into deleted-lines
            finally (push (make-instance 'chunk
                                         :kind (if (plusp (modified-length region))
                                                   :replace
                                                   :delete)
                                         :lines deleted-lines)
                          (window-chunks window))))
    ;; Now for the inserts.
    (when (plusp (modified-length region))
      (loop for index from (modified-start region)
            below (+ (modified-start region) (modified-length region))
            collect (modified-line context index) into inserted-lines
            finally (push (make-instance 'chunk
                                         :kind (if (plusp (original-length region))
                                                   :insert
                                                   :create)
                                         :lines inserted-lines)
                          (window-chunks window))))))

;;; Actually producing diffs.
(defun walk-diff-regions (context diff-regions)
  (dolist (region diff-regions)
    (process-region context region))
  ;; Pick off any stragglers.  FIXME: is this appropriate for a generic
  ;; operation like WALK-DIFF-REGIONS?  Maybe there should be a function
  ;; like FINALIZE-CONTEXT or some such.
  (when (current-window context)
    (add-window context (current-window context)))
  (let ((diff (diff context)))
    (setf (diff-windows diff) (nreverse (diff-windows diff)))
    diff))

(defun create-diff-generator (diff-kind interner
                                      original-pathname original-lines
                                      modified-pathname modified-lines)
  (make-instance 'diff-generator
                 :interned-lines interner
                 :original-lines original-lines
                 :modified-lines modified-lines
                 :diff (make-instance diff-kind
                                      :original-pathname original-pathname
                                      :modified-pathname modified-pathname)))

(defgeneric render-diff (diff stream)
  (:documentation "Print DIFF object to STREAM"))

(defgeneric render-diff-window (window stream)
  (:documentation "Print WINDOW to STREAM"))

(defun string-lines (string)
  (let ((start 0)
        (end (position #\Newline string)))
    (cons (apply 'subseq string start (and end (list end)))
          (and end (string-lines (subseq string (1+ end)))))))

(defun intern-seqs (&amp;rest seqs)
  (let ((interner (make-interner))
        (interned-seqs nil))
    (dolist (seq seqs (values interner (nreverse interned-seqs)))
      (let ((interned-seq nil))
        (loop :for line :in seq :do
           (let ((code (intern-string interner line)))
             (push code interned-seq)))
        (push (coerce (nreverse interned-seq) 'simple-vector) interned-seqs)))))

(defgeneric intern-lines (interner object)
  (:method (interner (list list))
    (coerce (loop for line in list 
               collect (intern-string interner line))
            'cl:vector))

  (:method (interner (string string))
    (intern-lines interner (string-lines string)))
  (:method (interner (file pathname)
            &amp;aux lines)
    (do-file-lines (l file (nreverse lines))
      (push (intern-string interner l) lines))))

#+(or)(multiple-value-bind (interner interned-seqs)
      (intern-seqs original-seq modified-seq)
    (let* ((original (first interned-seqs))
           (modified (second interned-seqs))
           (lcs (compute-lcs original modified)))
      (let ((diff-regions (convert-lcs-to-diff lcs))
            (context (create-diff-generator diff-kind interner
                                            "original" original
                                            "modified" modified)))
        (walk-diff-regions context diff-regions))))

(defun make-diff (original modified &amp;key (kind 'unified-diff))
  "=&gt; DIFF 
Compute a diff between ORIGINAL and MODIFIED

:KIND indicates the type of DIFF generated and should be the symbol
SMUG/LITERATE/DIFF:UNIFIED-DIFF or SMUG/LITERATE/DIFF:CONTEXT-DIFF."
  (flet ((diff-name (thing &amp;optional (alt "alternate"))
           (etypecase thing
             (pathname thing)
             (t alt))))
  (let* ((interner (make-interner))
         (original-lines (intern-lines interner original))
         (modified-lines (intern-lines interner modified))
         (lcs (compute-lcs original-lines modified-lines)))
    (let ((diff-regions (convert-lcs-to-diff lcs))
          (context (create-diff-generator 
                    kind interner
                    (diff-name original "original")
                    original-lines
                    (diff-name modified "modified")
                    modified-lines)))
        (walk-diff-regions context diff-regions)))))

(defun generate-seq-diff (diff-kind original-seq modified-seq)
  "Compute a diff between ORIGINAL-PATHNAME and MODIFIED-PATHNAME."
  (multiple-value-bind (interner interned-seqs)
      (intern-seqs original-seq modified-seq)
    (let* ((original (first interned-seqs))
           (modified (second interned-seqs))
           (lcs (compute-lcs original modified)))
      (let ((diff-regions (convert-lcs-to-diff lcs))
            (context (create-diff-generator diff-kind interner
                                            "original" original
                                            "modified" modified)))
        (walk-diff-regions context diff-regions)))))

(defun generate-diff (original-pathname modified-pathname
                       &amp;key (diff-kind))
  "Compute a diff between ORIGINAL-PATHNAME and MODIFIED-PATHNAME.
DIFF-KIND indicates the type of DIFF generated and should be the symbol
DIFF:UNIFIED-DIFF or DIFF:CONTEXT-DIFF."
  (multiple-value-bind (interner interned-files)
      (intern-files original-pathname modified-pathname)
    (let* ((original (first interned-files))
           (modified (second interned-files))
           (lcs (compute-lcs original modified)))
      (let ((diff-regions (convert-lcs-to-diff lcs))
            (context (create-diff-generator diff-kind interner
                                            original-pathname original
                                            modified-pathname modified)))
        (walk-diff-regions context diff-regions)))))






(defun format-diff (diff-kind original-pathname modified-pathname &amp;optional (stream *standard-output*))
  (render-diff (generate-diff diff-kind
                              original-pathname
                              modified-pathname)
               stream))

(defun format-diff-string (diff-kind original-pathname modified-pathname)
  (with-output-to-string (out)
    (format-diff diff-kind original-pathname modified-pathname out)))

;;; printing diffs on streams


(defmethod render-diff-window :before ((window unified-diff-window) stream)
  (let ((original-length (original-window-length window))
        (modified-length (modified-window-length window)))
    (format stream "@@ -~A" (1+ (original-start-line window)))
    (unless (zerop original-length)
      (format stream ",~A" original-length))
    (format stream " +~A" (1+ (modified-start-line window)))
    (unless (zerop modified-length)
      (format stream ",~A" modified-length))
    (write-string " @@" stream)
    (terpri stream)))

(defmethod render-diff-window :before ((window context-diff-window) stream)
  (format stream "***************~%"))

(defmethod render-diff-window ((object unified-diff-window) stream)
  (dolist (chunk (window-chunks object))
    (let ((prefix (ecase (chunk-kind chunk)
                    (:common #\Space)
                    ((:delete :replace) #\-)
                    ((:insert :create) #\+))))
      (dolist (line (chunk-lines chunk))
        (write-char prefix stream)
        (write-string line stream)
        (terpri stream)))))

(defun window-contains-deletes-p (window)
  (some #'original-chunk-p (window-chunks window)))

(defun window-contains-inserts-p (window)
  (some #'modified-chunk-p (window-chunks window)))

(defmethod render-diff-window ((window context-diff-window) stream)
  (let ((original-length (1- (original-window-length window)))
        (original-start-line (1+ (original-start-line window)))
        (modified-length (1- (modified-window-length window)))
        (modified-start-line (1+ (modified-start-line window))))
    ;; FIXME: lots of duplicated code, but factoring it out would result
    ;; in a function with about ten parameters...which is of dubious
    ;; usefulness.  Still, good style dictates that it should be done.
    ;; the original file comes first
    (format stream "*** ~A,~A ****~%" original-start-line
            (+ original-start-line original-length))
    (when (and (plusp original-length) (window-contains-deletes-p window))
      (dolist (chunk (window-chunks window))
        (unless (modified-chunk-p chunk)
          (let ((prefix (ecase (chunk-kind chunk)
                          (:common #\Space)
                          (:replace #\!)
                          (:delete #\-))))
            (dolist (line (chunk-lines chunk))
              (write-char prefix stream)
              (write-string line stream)
              (terpri stream))))))
    ;; now the modified file
    (format stream "--- ~A,~A ----~%" modified-start-line
            (+ modified-start-line modified-length))
    (when (and (plusp modified-length) (window-contains-inserts-p window))
      (dolist (chunk (window-chunks window))
        (unless (original-chunk-p chunk)
          (let ((prefix (ecase (chunk-kind chunk)
                          (:common #\Space)
                          (:insert #\!)
                          (:create #\+))))
            (dolist (line (chunk-lines chunk))
              (write-char prefix stream)
              (write-string line stream)
              (terpri stream))))))))

(defmethod render-diff :before ((diff unified-diff) stream)
  (format stream "--- ~A~%+++ ~A~%"
          (namestring (original-pathname diff))
          (namestring (modified-pathname diff))))

(defmethod render-diff :before ((diff context-diff) stream)
  (format stream "*** ~A~%--- ~A~%"
          (namestring (original-pathname diff))
          (namestring (modified-pathname diff))))

(defmethod render-diff ((object diff) stream)
  (dolist (window (diff-windows object))
    (render-diff-window window stream)))

;; Copyright (c) 2013, Drew Crampsie &lt;me@drewc.ca&gt;  All rights reserved.
;; Copyright (c) 2004, Nathan Froyd.  All rights reserved.

;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are
;; met:

;; * Redistributions of source code must retain the above copyright
;; notice, this list of conditions and the following disclaimer.

;; * Redistributions in binary form must reproduce the above copyright
;; notice, this list of conditions and the following disclaimer in the
;; documentation and/or other materials provided with the distribution.

;; * Neither the name of Nathan Froyd nor the names of the contributors to
;; this software may be used to endorse or promote products derived from
;; this software without specific prior written permission.

;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
;; IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
;; TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
;; PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
;; OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
;; EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
;; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;; PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;; LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;; NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</pre>


</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2014-03-23T10:54-0700</p>
<p class="author">Author: Drew Crampsie</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
