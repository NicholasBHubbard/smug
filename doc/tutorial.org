#+TITLE: SMUG Tutorial : Literate

  This tutorial started as a translation of _Monadic Parser
  Combinators_ [1], or at least the first half, into common lisp.

  The example code in the following document is completely
  self-contained, and does not require an installation of the ~SMUG~
  library.

  No prior experience with functional programming, monads or recursive
  descent parsing is assumed. The only requirements are a common lisp
  environment, and a burning desire to find a better way to parse.
  
* Introduction 

 This tutorial, like this library, is based on an approach to
 building parsers using higher-order functions (combinators) that is
 popular in the functional programming community. Incidentally, these
 parsers form an instance of something called a monad, which is
 itself a useful construct with implications beyond parsing.

 With great debt to Monadic Parser Combinators[fn:1], the paper from
 which this library is derived, this tutorial presents a step by step
 introduction to the topics of parser combinators and monads and
 their use in common lisp.

** Common Lisp

 In some cases, the natural name for a parser conflicts with a name in
 the ~COMMON-LISP~ package. Rather then shadow the symbols, I've
 chosen to prefix all parser names with a #\. character. It is thought that
 this aids usability, as one can simply ~(:use :smug/tutorial)~. It also
 helps to distinguish parser returning functions from other
 functions.

* How To Combine Parsers

#+BEGIN_QUOTE 
   A Parser for Things
   is a function from Strings
   to Lists of Pairs
   of Things and Strings!
   -- Fritz Ruehr, Willamette University [2]
#+END_QUOTE 

   A parser is something that is familiar to all programmers... a
   function that, given a series of tokens as input, produces a data
   structure that relates to the grammatical structure of the input in
   some way. Or, to put it simply, a function from strings to things.
   
#+BEGIN_SRC lisp
  ;; our fictional parser matches the string "string" 
  ;; and returns a SYMBOL thing    
  (parse-thing "string") => THING
#+END_SRC
   
   In order to combine simple parsers into larger more complex ones,
   they need a way to communicate between them. First, because any
   given parser might consume only a part of the input, we'll have our
   parser return a ~CONS~ with the result in the ~CAR~ and the remaining
   input in the ~CDR~.

   #+BEGIN_SRC lisp
     (parse-thing "string string") => (THING . " string")
   #+END_SRC

   Because a parser may return multiple results when the
   grammar is ambiguous, or may return no results all, we'll put our
   conses in a list, and have the empty list, ~NIL~, denote a failed
   parse.

   #+BEGIN_SRC lisp
     (parse-thing "string string") ;=> ((THING . " string"))
     (parse-thing "strong string") ;=> NIL
  #+END_SRC

  So, for our purposes, a parser is just a ~FUNCTION~ that takes a
  single value as the input and returns a ~LIST~ of ~CONS~'s of results
  and unconsumed input.
  
  It is this trivial protocol that allows us to combine small simple
  parsers into larger more useful ones.

* Reading Input

  Smug parsers allow infinite look-ahead and backtracking. To support
  parsing many different things, it's useful to define an input
  protocol. Smug parsers only require three operations on input :
  ~INPUT-FIRST~, ~INPUT-REST~ and ~INPUT-EMPTY-P~.  

  We'll define them in terms of strings. It serves our purposes and
  makes for a nice visual presentation.

  #+NAME: tutorial_reading-input
  #+BEGIN_SRC lisp
    (defgeneric input-empty-p (input)
      (:method ((input string)) (zerop (length input))))
    
    (defgeneric input-first (input)
      (:method ((input string)) (aref input 0)))
    
    (defgeneric input-rest (input)
      (:method ((input string))
        (multiple-value-bind (string displacement) 
            (array-displacement input)      
          (make-array (1- (length input))
                      :displaced-to (or string input)
                      :displaced-index-offset (1+ displacement)
                      :element-type (array-element-type input)))))
  #+END_SRC
  
  
  #+BEGIN_SRC lisp
    (input-empty-p "") => t
    (input-empty-p "foo")
    (input-first "foo") => #\f
    (input-rest "foo") => "oo"
  #+END_SRC

* The Three Primitive Parsers

  There are 3 simple primitive parsers. It it only necessary to
  understand them, and one sequencing combinator, ~.BIND~, to understand
  all of ~SMUG/TUTORIAL~.

** ~.RESULT~

    The first parser is ~.RESULT~, which always succeeds by returning the
    value passed to it,  and does not consume any input. Because we've
    earlier defined parsers as functions that take a single argument
    we'll make a curry[5] with the input parameter.

#+NAME: tutorial_.result
#+BEGIN_SRC lisp
  (defun .result (value)
    (lambda (input)
      (list (cons value input))))
#+END_SRC

#+NAME: tutorial-test_.result
#+BEGIN_SRC lisp
  (test> (funcall (.result :foo) "bar baz")
         => ((:foo . "bar baz")))
#+END_SRC

** ~.FAIL~ 

    The second parser, ~.FAIL~, is the inverse behaviour of
    ~.RESULT~. It simply fails regardless of the input. we could
    define ~.FAIL~ as a function that takes a single argument, but then
    we'd have to access it using ~FUNCTION~ (#'), and aesthetically that
    inconsistency is undesirable, so we'll again make curry with the
    input parameter.

#+NAME: tutorial_.fail
#+BEGIN_SRC lisp
(defun .fail ()
  (lambda (input) (declare (ignore input)) nil))
#+END_SRC

#+NAME: tutorial-test_.fail
#+BEGIN_SRC lisp
(test> (funcall (.fail) "foo") => NIL)
#+END_SRC

** ~.ITEM~

    The last true primitive is .~.ITEM~, which is a parser that
    consumes the first token in the input, or fails in the input is
    empty.

#+NAME: tutorial_.item
#+BEGIN_SRC lisp
(defun .item ()
  (lambda (input)
    (unless (input-empty-p input)
      (list (cons (input-first input)
		  (input-rest input))))))
#+END_SRC

#+NAME: tutorial-test_.item
#+BEGIN_SRC lisp
  (test> (funcall (.item) "foo") 
         => ((#\f . "oo")))

  (test> (funcall (.item) "") 
         => NIL)
#+END_SRC

* ~RUN~, ~PARSE~: ~FUNCALL~ and ~CAAR~ in disguise

All the primitives return a ~FUNCTION~ that must be ~FUNCALL~'ed with ~INPUT~ in
order to run the parser. 

There are many reasons to define a ~RUN~ function. We can ~CL:TRACE~
it, or change the input parameter ~TYPE~, or change what the actual
primitives return.

#+NAME: tutorial_run
#+BEGIN_SRC lisp
  (defun run (parser input)
    (funcall parser input))
#+END_SRC

The ~RUN~ function returns the entire parse tree. Most of the time we
simply want the ~CAR~ of the ~FIRST~ result. The ~CDR~ is the leftover
input, and the ~REST~ of the result alternative outcomes. We might
want these as well, so we return the as ~VALUES~.

#+NAME: tutorial_run
#+BEGIN_SRC lisp 
  (defun parse (parser input)
    (let ((result (run parser input)))
      (when result 
        (destructuring-bind ((result . input) &rest rest)
            result      
          (apply #'values result input rest)))))
#+END_SRC

#+RESULTS: tutorial_run
: PARSE

* ~.BIND~: Our first primitive combinator

   Now that we have our primitive parsers, we need a way to combine
   them. We'd like to be able to apply parsers in sequence, and it
   would also come in handy if we could give names to the intermediate
   results of parsers. Both these requirements are fulfilled by using
   the monadic sequencing operator, ~.BIND~.

   ~.BIND~ is a function that takes as arguments a parser P, and a
   function F which take a value and returns a parser P2. ~.BIND~ returns
   a parser that first applies P to the input, returning a list of
   ~(VALUE . INPUT)~ pairs. The the function ~F~ is applied to each ~VALUE~,
   and the result ~P2~ then applied to the ~INPUT~. The collected lists of
   pairs returned from the ~P2~'s are then concatenated and the result
   returned.

#+NAME: tutorial_.bind
#+BEGIN_SRC lisp
  (defun .bind (parser function)
    (lambda (input)
      (loop :for (value . input) :in (run parser input)
            :append (run (funcall function value) input))))
#+END_SRC

#+NAME: tutorial-test_.bind
#+BEGIN_SRC lisp
  (let ((char-token
         (.bind (.item) 
               (lambda (char) 
                 (.result (list :char char))))))           
    (run char-token "foo"))
  ;; ~> (((:CHAR #\f) . "oo"))
#+END_SRC

   Because ~.BIND~ itself returns a parser, the result of a ~.BIND~ can be
   returned as P2. This allows parsers to be chained, and allows us to
   use ~LAMBDA~ to provide names for the values of parser results. For
   example, the following parser uses ~.BIND~ to return the first two
   characters as a cons.

#+BEGIN_SRC lisp
(let ((two-chars 
       (.bind (.item) 
	     (lambda (char) 
	       (.bind (.item) 
		     (lambda (char2) 
		       (.result (cons char char2))))))))
  (run two-chars "asd"))
;;=> (((#\a . #\s) . "d"))
#+END_SRC

   The next section gets into some details about why our parser is a
   monad.  You don't really need to know this, so feel free to [[**Some%20Parsers%20Using%20Bind][skip it]]
   if you're in a hurry.

** A quick word on monads

   By virtue of having the functions ~.BIND~ and ~.RESULT~ defined as they
   are, our parser interface forms a monad. A monad is, essentially,
   a category of things that provide the functions ~.BIND~ and ~.RESULT~.
   
   Of course, just having functions called ~.BIND~ and ~.RESULT~ does not a
   monad make. There are other contracts that ~.BIND~ (also known as
   pipe, >>~, *, or let) or ~.RESULT~ (aka lift, unit, return) must
   fulfill.

*** The monad laws

    In order to be properly categorized as a monad, the thing
    providing a definition for ~.BIND~ and ~.RESULT~ must obey three laws
    (a static functional programmer would say 'must have a certain
    type', but the word type means something different to a dynamic
    functional programmer, so we'll avoid it here)

    In order to describe those laws we need to define a few terms

    - Monadic Value (MV) :: a function that, given a value, returns a
	 value in the form expected by the internals of ~.BIND~. In our
	 examples above, a parser (taking an input and returning a
	 list of results) is the Monadic Value.

    - Monadic Function (MF) :: A function that, given a value returns
	 a monadic value encapsulating that value. ~.RESULT~ is the
	 canonical Monadic Function
    
    In Object-Oriented terms, the MF is a constructor, and the MV an
    object.

    The laws which all things must obey in order to be called a monad
    are simple :

    - "Left identity" ::  (bind (result x) MF) = (funcall MF x)

    - "Right identity" :: (bind MV result) = MV

    - "Associativity" ::  (bind (bind MV MF) MF2) 
	 = (bind MV (lambda (x) (bind (MF x) MF2)))
    
    With static type systems, the compiler will enforce this contract
    for you. In a dynamic system, we just need to be a little more
    careful. Proving the monad laws for our ~.BIND~ and ~.RESULT~ is
    left as an exercise.

    That's really all there is to monads except for syntax, which
    we'll get to later. There are extended laws that other monads
    obey, and monads have other uses beyond parsing, but we're
    reaching the end of our scope already.

* ~.SATISFIES~  : the parser predicate

    Often, we only want to consume input if a certain
    condition is true. This where ~.SATISFIES~ comes in.

#+NAME: tutorial_.satisfies
#+BEGIN_SRC lisp
(defun .satisfies (predicate &rest args)
  (.bind (.item) 
	(lambda (x) 
	  (if (apply predicate x args)
	      (.result x)
	      (.fail)))))
#+END_SRC

#+RESULTS:
: TEST>

#+NAME: tutorial-test_.satisfies
#+BEGIN_SRC lisp
(run (.satisfies #'digit-char-p) "1 and") 
;;=> ((#\1 . " and"))
#+END_SRC


   If ~.ITEM~ fails, so will the ~.SATISFIES~ parser. This is because (bind
   (fail) MF) will always fail. ~.FAIL~, also known as ~.ZERO~, is a function
   belonging to a category of monads knows as "monads with a
   zero". That's not terribly important for parsing, but interesting if
   you're into that sort of thing.

** ~.IS~ and ~.IS-NOT~

Imagine we need to parse all characters that come before a ~#\;~. The
simple way is to have a function that uses ~CL:NOT~.

#+BEGIN_SRC lisp
  (.satisfies 
   (lambda (item)
     (not (char= #\; item))))
#+END_SRC


It turns out that ~(.satisfies (lambda (i) (not ...)))~ is quite
common, so we define a parser that has a shorter and more relevant
name.

#+NAME: tutorial_.is-not
#+BEGIN_SRC lisp
(defun .is-not (predicate &rest args)
  (.satisfies (lambda (i) 
                 (cl:not (apply predicate i args)))))
#+END_SRC

This makes things a lot shorter and easier to read.

#+NAME: tutorial_test.is-not 
#+BEGIN_SRC lisp :results output code
  (test> 
   (run (.is-not #'char= #\;) "foobar;%^*&")       
   => ((#\f . "oobar;%^*&")))
#+END_SRC

#+NAME: tutorial_test.is-not 
#+BEGIN_SRC lisp :results output code
  (test> 
   (run (.is-not #'char= #\;) ";%^*&")
   => NIL)
#+END_SRC


For that matter, now that we have ~.IS-NOT~, ~.SATISFIES~ is a bit
long, and does not prefix ~-NOT~ . So we type a few keys in
order to save a bundle in the future.

#+NAME: tutorial_.is
#+BEGIN_SRC lisp
  (defun .is (predicate &rest args)
    (apply #'.satisfies predicate args))
#+END_SRC

** Example Parsers for letters and numbers using ~.SATISFIES~

     ~.SATISFIES~ allows us to ~DEFUN~ some simple parsers

#+NAME: tutorial_char=digit-char|lower-case-p
#+BEGIN_SRC lisp
  (defun .char= (x)
    (.is #'cl:char= x))
  
  (defun .digit-char-p ()
    (.is #'cl:digit-char-p))
  
  (defun .lower-case-p ()
    (.is #'cl:lower-case-p))
  
  (defun .upper-case-p ()
    (.is #'cl:upper-case-p))  
 #+END_SRC


#+NAME: tutorial-test_char=digit-char|lower-case-p
#+BEGIN_SRC lisp
  (run (.char= #\x) "xyzzy") ;=> ((#\x . "yzzy"))
  (run (.digit-char-p) "1234") ;=> ((#\1 . "234"))
  (run (.lower-case-p) "abcd") ;=> ((#\a . "bcd"))
  (run (.upper-case-p) "Abcd") ;=> ((#\A . "bcd"))  
  (run (.upper-case-p) "doh!") ;=> NIL

#+END_SRC
* ~.PLUS~, the non-deterministic choice combinator

   If we want to combine our earlier parsers, say to create an
   ~ALPHANUMERIC-CHAR~ from ~UPPER-CASE-P~ and ~LOWER-CASE-P~ we need
   a combinator capable of making the choice between them.

   In some cases, it may not be an exclusive choice. There might be
   multiple ways to parse a string, or a later pass might resolve the
   ambiguity.

   For example, in one of our earlier examples of ~.BIND~, we saw a
   parser that returned the first two characters in a stream. This
   parser will fail if there is only one character left in the input.

#+BEGIN_SRC lisp
(let ((two-chars 
       (.bind (.item) 
	     (lambda (char) 
	       (.bind (.item) 
		     (lambda (char2) 
		       (.result (cons char char2))))))))
  (funcall two-chars "a"))
;;=> NIL
#+END_SRC   

  If we want to parse one or two characters, or an arbitrarily long
  series of characters, we need some a way to express that.

  Enter the ~.PLUS~ combinator.

#+NAME: tutorial_.plus
#+BEGIN_SRC lisp
  (defun .plus (first-parser second-parser)
    (lambda (input)
      (append (funcall first-parser input) (funcall second-parser input))))
#+END_SRC

#+NAME: tutorial-test_.plus
#+BEGIN_SRC lisp
  (let ((two-chars 
         (.bind (.item) 
               (lambda (char) 
                 (.bind (.item) 
                       (lambda (char2) 
                         (.result (cons char char2))))))))
    (funcall (.plus two-chars (.item)) "a") 
    ;;=> ((#\a . "")) 
    (funcall (.plus two-chars (.item)) "asd")
    ;;=> (((#\a . #\s) . "d") (#\a . "sd"))
    )
#+END_SRC

  Note that the second parse returned two pairs, as both parsers were
  successful. The string parsed as both two chars and a single item.

** Example parsers using PLUS

    The examples used in the original paper[1] are for letters and
    alphanumeric characters. There's no good reason to use them over
    /(.is #'alpha-char-p)/and the like, but they do serve as 
    simple example.

#+BEGIN_SRC lisp
(defun letter () (plus (lower-case-char) (upper-case-char)))

(funcall (letter) "foo") => ((#\f . "oo"))
(funcall (letter) "1foo") => NIL

(defun alphanumeric () (plus (letter) (.digit-char)))

(funcall (alphanumeric) "1foo") => ((#\1 . "foo"))
(funcall (alphanumeric) "!1foo") => NIL
#+END_SRC

  The other example is more illustrative, a parser that returns a
  series of letters or the empty string.

#+BEGIN_SRC lisp
(defun word ()
  (let ((non-empty-letters 
	 (bind (letter) 
	       (lambda (first-letter) 
		 (bind (word)
		       (lambda (rest-of-letters)
			 (result (format nil "~A~A" 
					 first-letter
					 rest-of-letters))))))))
    (plus non-empty-letters (result ""))))

(funcall (word) "asd")
=>
(("asd" . "") ("as" . "d") ("a" . "sd") ("" . "asd"))

#+END_SRC

  This is our first recursive parser, but it's a common idiom. Notice
  that it returns all the possible strings of letters. 

  This is obviously inefficient when one only requires the first value.
  required, a deterministic combinator ~.OR~, will be introduced later
  in the tutorial.

** Efficiency 

   ~.FIRST~ is the real choice when it comes down to it, as ~.PLUS~ really does matter.

#+NAME: tutorial_.first
#+BEGIN_SRC lisp
(defun .first (parser)
  (lambda (input)
    (let ((results (run parser input)))
       (when results (list (cl:first results))))))
#+END_SRC

*** TODO Explain more about ~.FIRST~
   
* Syntax : ~LET*~ and the identity monad

   If you read the earlier section on monads, you'd know that ~.BIND~
   and ~.RESULT~ are the interface to many different types of monads,
   of which our parser is but one example. If you didn't, you know
   now. Again, if you're not at all interested and really just want to
   keep on parsing, [[%20defmacro%20letstar][skip down to the macro]]. 

   The most basic monad is the identity monad. A definition of its
   ~.BIND~ and ~.RESULT~ might look like the following.

#+BEGIN_SRC lisp

(defun i-bind (mv mf) (funcall mf mv))
(defun i-result (value) value)

#+END_SRC

    In Lisp, the identity monad is so trivial as to be useless. In a
    functional programming language, or any language where the order
    of operations is not guaranteed, the identity monad serves to
    sequence operations.

    Imagine a silly lisp where the order of evaluation isn't defined
    as strict left to right[3]. The following form could have
    disastrous consequences.

#+BEGIN_SRC lisp

(progn (remove-gun-from-pants)
       (point-gun-at-bad-guy)
       (pull-trigger))

#+END_SRC

   The identity monad makes the sequencing explicit. In a purely
   functional lisp, one might sequence the operations as follows.

#+BEGIN_SRC lisp
(i-bind (remove-gun-from-pants) 
      (lambda (gun)
	(i-bind (point-gun-at-bad-guy gun)
	      (lambda (pointed-gun)
	      (i-bind (pull-trigger pointed-gun)
		      (lambda (fired-gun)
			(i-result fired-gun)))))))
#+END_SRC

   In functional programming languages this pattern is so common that
   there is special syntax for it. The usual choices are 'do notation'
   or 'list comprehension syntax'.

   First, the previous example rendered in list comprehension
   notation :

#+BEGIN_SRC haskell
[fgun | gun <- removeGun 
      , pgun <- pointGunAtBadGuy gun
      , fgun <- pullTrigger pgun] 
        
#+END_SRC

   And in do notation :

#+BEGIN_SRC haskell
do 
  gun <- removeGun 
  pgun <- pointGunAtBadGuy
  fgun <- pullTrigger pgun
  return fgun
#+END_SRC

   The astute lisper might notice that do notation looks a lot like
   LET*. In fact, that's really all it is. LET* is lisp syntax for the
   identity monad, and our i-bind using forms above are directly
   translatable.

#+BEGIN_SRC lisp 
(let* ((gun (remove-gun-from-pants))
       (pointed-gun (point-gun-at-bad-guy gun))
       (fired-gun (pull-trigger pointed-gun)))
  (identity fired-gun))
#+END_SRC

  One could legitimately say that the common lisp package is an
  instance of the identity monad, if one cared for such insights.

** ~.LET*~, our version of ~LET*~ like do notation
# << defmacro letstar >>

    A ~LET*~ like construct is the obvious notation for a lisper to take
    advantage of the monadic nature of parsers. It's often useful to
    ignore a value. In haskell, the underscore character is used to
    denote an ignorable variable, so we'll use the same convention.

#+NAME: tutorial_.letstar
#+BEGIN_SRC lisp
  (defmacro .let* (bindings &body body)
    (if bindings
        (let ((symbol (first (first bindings))))
          `(.bind ,@(cdr (first bindings))
                 (lambda (,symbol)
                   ,@(when (string-equal (symbol-name symbol) "_")
                           `((declare (ignorable ,symbol))))
                   (.let* ,(cdr bindings)
                     ,@body))))
        `(progn ,@body)))
#+END_SRC

#+BEGIN_SRC lisp
  (funcall (.let* ((a (.result 1)))
             (.result a)) "")
#+END_SRC

If we replace ~.BIND~ with our ~I-BIND~ function above, we get a macro
that is equivalent to ~LET*~. ~.LET*~ binds the results of parsers,
and is a much nicer way to work over nesting ~.BIND~'s.

** Examples using ~.LET*~

    Using recursion like we did in our WORD parser, we'll create a
    parser that matches a specific string.

# << tutorial_.string= >>
#+NAME: tutorial_.string=
#+BEGIN_SRC lisp
  (defun .string= (string)
    (if (string= string "")
        (.result nil)
        (.let* 
            ((_ (.is 'char= (aref string 0)))
             (_ (.string= (subseq string 1))))
          (.result string))))
  #+END_SRC


#+NAME: tutorial-test.string=
#+BEGIN_SRC lisp :results output code
(run (.string= "asdf")  "asdfjkl") => (("asdf" . "jkl"))
#+END_SRC

#+BEGIN_SRC lisp :results output code
(run (.string= "asdf")  "asd") => NIL
#+END_SRC

    Once can see how much nicer ~.LET*~ notation is, and also how the
    ignorable ~_~ comes in handy. 

* ~.MAP~ : The repetition combinator
   
   Earlier, we defined a parser, ~.WORD~, using ~.BIND~ and a recursive
   call. Lets define a similar parser using ~.LET*~ that returns a list
   of letters.

#+BEGIN_SRC lisp
  (defun .letters ()
    (.plus (.let* ((x (.letter))
                 (xs (.letters)))
           (.result (cons x xs)))
         (.result nil)))
#+END_SRC 

   This pattern can easily be abstracted into a more general
   combinator, ~.ZERO-OR-MORE~

** ~.ZERO-OR-MORE~

#+BEGIN_SRC lisp
  (defun .zero-or-more (parser)
    (.plus (.let* ((x parser)
                   (xs (.zero-or-more parser)))
             (.result (cons x xs)))
           (.result ())))
#+END_SRC 

#+BEGIN_SRC lisp
  (test> 
   (run (.zero-or-more (.char= #\a)) "aaaab"
   =>  (((#\a #\a #\a #\a) . "b") ((#\a #\a #\a) . "ab") ((#\a #\a) . "aab")
        ((#\a) . "aaab") (NIL . "aaaab")))
  
  (test> 
   (run (.zero-or-more (.char= #\a)) "bbbba")
   =>
   ((NIL . "bbbba")))
#+END_SRC 

   Note that zero or more always succeeds. If one needs a parser that
   matches one or more items and fails otherwise, we can define one in
   terms of ZERO-OR-MORE, can call it, appropriately enough,
   ONE-OR-MORE.

** ~.ONE-OR-MORE~

#+BEGIN_SRC lisp
(defun .one-or-more (parser)
  (.let* ((x parser)
	  (y (.zero-or-more parser)))
    (.result (cons x y))))

(test> (funcall (.one-or-more (.char= #\a)) "aaaab")
  =>
 (((#\a #\a #\a #\a) .many "b")))

(test> (funcall (.one-or-more (.char= #\a)) "bbbba")
   => NIL)
#+END_SRC 


We could now define a ~TWO-OR-MORE~ and ~THREE-OR-MORE~ etc., but it
is likely better to define a function to rule them all. It needs a
base to rule from.

** /Function/ ~.MAPC~, ~.MAPCAR~

# ~.MAPCAN~, ~.MAPL~, ~.MAPLIST~, ~.MAPCON~

*Syntax:*

~.mapc~ /parser/  => /parser/

~.mapcar~ /parser/ => /result-list/

# mapcan function &rest lists+ => concatenated-results

# mapl function &rest lists+ => list-1

# maplist function &rest lists+ => result-list

# mapcon function &rest lists+ => concatenated-results

*Arguments and Values:*

 - /parser/ :: The parser that is attempted
 - /result-list/ :: a list

*Description:* 

The mapping operation involves attempting /parser/ many times. Except
for ~.mapc~ and ~.mapl~, the result contains the results returned by
the /parser/. 

# In the cases of mapc and mapl, the resulting sequence is list.

~.MAPCAR~ operates on successive results of /parser/. The iteration
terminates when the /parser/ fails. The value returned by mapcar is a
list of the results of /parser/

#+name: tutorial-.mapcar
#+BEGIN_SRC lisp
(defun .mapcar (parser)
    (.plus (.let* ((x parser)
                   (xs (.mapcar parser)))
             (.result (cons x xs)))
           (.result ())))
#+END_SRC

#+RESULTS:
: \.MAPCAR

~.MAPC~ is like ~.MAPCAR~ except that the results of applying function are
not accumulated. The /parser/ argument is returned as a result.

#+name: tutorial-.mapc
#+BEGIN_SRC lisp
(defun .mapc (parser)
    (.plus (.let* ((_ parser)
                   (_ (.mapc parser)))
             (.result parser))
           (.result parser)))
#+END_SRC

#+RESULTS:
: \.MAPC

*Examples:*

#+BEGIN_SRC lisp :results output code
   
   (test> (parse (.prog1 (.mapcar (.item))
                          (.char= #\!))
                  "Yay!")
     => (#\Y #\a #\y))
 
#+END_SRC

#+BEGIN_SRC lisp :results output code     
  (let ((/parser/ (.item)))
    (test> (parse (.let* ((parser (.prog1 (.mapc /parser/)
                                          (.char= #\!)))
                          (char parser))
                    (.result (cons (eq parser /parser/)
                                   char)))
                  "Holy Guacamole!?")
           =>(T . #\?)))                       
#+END_SRC

** /Function/ ~.MAKE-LIST~, ~.MAKE-SEQUENCE~

Often, we know what we want, and how many we want, all at once. So,
just like ~CL:MAKE-LIST~, we take a number.

*Syntax:*

~.make-list~ /size/ /&key/ /initial-element/ => /list/

~.make-sequence~ /result-type/ /size/ /&key/ /initial-element/ => /list/

*Arguments and Values:*

 - /size/ :: a non-negative integer.

 - /initial-element/ :: a /parser/. The default is ~(.item)~.

 - /list/ :: a list.

*Description:*

Returns a /list/ of /length/ given by /size/, each of the elements of
which is a successful run of the /initial-element/ parser.

#+name: tutorial-.make-list
#+BEGIN_SRC lisp
  (defun .make-list (size &key (initial-element (.item)))
    (if (zerop size) 
        (.result nil)
        (.let* ((first initial-element)
                (rest (.make-list (1- size) 
                                  :initial-element initial-element)))
          (.result (list* first rest)))))               
#+END_SRC

#+name: tutorial-.make-sequence
#+BEGIN_SRC lisp  
  (defun .make-sequence (type length &key (initial-element (.item)))
    (.let* ((list (.make-list length :initial-element initial-element)))
      (.result (coerce list type))))               
#+END_SRC

** /Function/ ~.CONCATENATE~ 

There are often mulitple parsers that are run one after another, and
the results joined together at the end. ~.CONCATENATE~ takes care of
that.

#+NAME: tutorial-.concatenate
#+BEGIN_SRC lisp
  (defun .concatenate (output-type-spec &rest parsers)
    (if (not parsers)
        (.fail)
        (.let* ((first (first parsers))
                (rest (if (rest parsers)
                          (apply 
                           #'.concatenate output-type-spec (rest parsers))
                          (.result nil))))
          (.result (cl:concatenate output-type-spec first rest)))))
  
#+END_SRC


** ~.MAP~ : ONE /FUNCTION/ TO RULE THEM ALL!

In the end

The ~:AT-LEAST~ keyword solves the "how many do we want to start
with?". We have decided on ~1~ as the default, as most of the time we
do want the parser to succeed, and besides that, ~.OPTIONAL~ is a
better way of saying ~:at-least 0~.

# There is also the simple matter of using ~.PLUS~
# or *<whatever>*. The ~:USING~ argument takes care of that.

So, we can specify the ~.MAP~ parser as follows.

#+NAME: tutorial_.map
#+BEGIN_SRC lisp
  (defun .map (result-type parser
               &key 
                 (at-least 1))
    "=> a ~result-type~ of /parser/ results."
    (.let* ((list-1 (.make-list at-least :initial-element parser))
            (list-2 (funcall (if result-type #'.mapcar #'.mapc) parser)))
      (.result (when result-type (concatenate result-type list-1 list-2)))))
#+END_SRC

#+RESULTS: tutorial_.map
: \.MAP

** Examples using ~.MAP~

    Let's make a parser for standard quoted strings. We'll use
    the #\' character as the quotes, and the #\| character as the
    escape character, simply to make it easier to embed in our example
    text in common lisp strings.

#+BEGIN_SRC lisp :results value 
  (defun .quoted-string (&key (quote #\')
                           (escape #\|))
    (.let* ((_ (.char= quote))
            (string 
             (.map 'string 
                   (.plus (.let* ((_ (.char= escape)))
                            (.item))
                          (.is-not 'char= quote))))
            (_ (.char= quote)))
      (.result string)))
  
  
#+END_SRC

| (The quote char is ' and the escape char is | . . '') |

* ~.OR~, ~.NOT~, and ~.AND~ : deterministic logic combinators
** ~.OR~

   ~.OR~ is a deterministic ~.PLUS~. It take any number of parsers. The
   first parser is run, and if it succeeds, evaluation short circuits
   and the result of the parser is returned. Otherwise, the next
   parser is run, and so on, until one succeeds or there are no more
   parsers. 
   
   We can't use ~.BIND~ or ~.LET*~ for ~.OR~ because it would fail if one of
   its parsers fails. As such, ~.OR~ must be a primitive.

#+NAME: tutorial_.or
#+BEGIN_SRC lisp
(defun .or (parser &rest parsers)
  (lambda (input)
    (or (funcall parser input) 
	(when parsers 
	  (funcall (apply #'.or parsers) input)))))
#+END_SRC 

** ~.NOT~
   Similarly, ~.NOT~, which continues parsing only when the parser
   fails, is primitive as well.
#+NAME: tutorial_.not
#+BEGIN_SRC lisp
(defun .not (parser)
  (lambda (input)
    (let ((result (funcall parser input)))
      (if result
	  nil
	  (list (cons t input))))))
#+END_SRC

** ~.AND~

   On the other hand, ~.AND~ can be defined in terms of ~IF~, and
   doesn't even need to test for failure, as ~.BIND~ handles failure
   automatically.

   ~.AND~ (known as '>>' in haskell) sequentially composes parsers,
   discarding the results of all but the last one, and returning that
   result.

#+NAME: tutorial_.and
#+BEGIN_SRC lisp
(defun .and (p1 &rest ps)
  (.let* ((result p1))
    (if ps
	(apply #'.and ps)
	(.result result))))

#+END_SRC

** Examples using  ~.OR~, ~.NOT~, and ~.AND~
*** ~.NO-MORE-INPUT~

    Now that we have ~.NOT~, we can specifically test for failure rather
    than abort the parse entirely. since the primitive parser ~.ITEM~
    only fails when the input is empty, we can define ~.NO-MORE-INPUT~ by
    negating it.

#+name:tutorial_.no-more-input
#+BEGIN_SRC lisp
  (defun .no-more-input ()
   (.not (.item)))
#+END_SRC

*** ~.PROGN~, ~.PROG1~, ~.PROG2~
    Using ~.AND~, we can implement ~.PROGN~ (which is really just
    ~.AND~ because it will fail when the parser does), ~.PROG1~ (which
    comes in handy for matching things and the end of the line, or
    when there is no more input) and ~.PROG2~, which as we will see is
    also quite useful.

#+NAME: tutorial_.progn    
#+BEGIN_SRC lisp
  (defun .progn (&rest parsers)
    (apply #'.and parsers))
  
  (defun .prog1 (parser &rest parsers)
    (.let* ((result parser)
            (_ (apply #'.and parsers)))
      (.result result)))
  
  (defun .prog2 (parser1 parser2 &rest parsers)
    (.and parser1 (apply #'.prog1 parser2 parsers)))
#+END_SRC

*** ~.OPTIONAL~

  The OPTIONAL combinator, which allows a parser to fail and still
  continue, is a natural use of ~.OR~.  

#+NAME: tutorial_.optional
#+BEGIN_SRC lisp
  (defun .optional (parser)
    (.or parser (.result nil)))
#+END_SRC 

  Finally, using ~.OR~, ~.AND~ and ~.NOT~, we can make parser versions of
  the lisp conditionals we all know and love.

#+BEGIN_SRC lisp
  
  (defun .if (test-parser then-parser 
              &optional (else-parser (.fail)))
    (let ((no (gensym)))
      (.let* ((no? (.or test-parser (.result no))))
        (if (not (eq no? no))
            then-parser
            else-parser))))
  
  (defun .when (test-parser then-parser)
     "we define .when in terms of .IF, but it's really just .AND again"
    (.if test-parser then-parser))
  
  (defun .unless (test-parser then-parser)
     "defined in term of .when, even though it's just (.AND (.NOT ...))"
    (.when (.not test-parser) then-parser))
  
#+END_SRC
    
* Parsing S-Expressions

#+BEGIN_SRC lisp
  (defun .sexp ()
    (.prog2 (.optional (.whitespace))
            (.or (.list) (.atom)  )
            (.optional (.whitespace))))
  
  (defun .atom ()
     (.first (.map 'string (.constituent))))
  
  (defun .constituent ()
    "http://www.lispworks.com/documentation/HyperSpec/Body/02_ad.htm"
    (let ((non-constituent
           (list* #\( #\) (whitespace))))
    (.or (.is-not 'member non-constituent)
         (.and (.char= #\\) (.item)))))
  
  (defvar *nil* (gensym))
  
  (defun .nil ()
    (.and (.or (.string-equal "NIL")
               (.string= "()"))
          (.result *nil*)))
  
  (defun .dot ()
    (.prog2 (.optional (.whitespace))
            (.char= #\.)
            (.optional (.whitespace))))
  
  
  
          
  (defun whitespace ()
    '(#\space #\newline #\tab))
  
  (defun .whitespace ()
    (.first (.map 'list (.is 'member (whitespace)))))
  
  (defun .list (&key delimited &aux (not (gensym)))
    (.or (.nil)
         (.let* ((_ (if (not delimited) 
                        (prog1 (.char= #\() 
                          (setf delimited #\)))
                        (.result nil)))
                 (first (.sexp))
                 (dot (.optional (.dot)))
                 (rest (if dot 
                           (.sexp) 
                           (.or (.list :delimited #\))
                                (.and (.char= delimited)
                                      (.result :nil))))))
           (.result (list* first rest)))))
  
  
  (defun .list (&key 
                  (start (.char= #\())
                  (end (.char=  #\))))
    (.or 
     (.let* ((start (or start
                    (.result nil)))
             (first (.optional (.sexp)))
             (rest (if first
                       (.optional (.list :start nil :end nil))
                       (.result nil)))
             (end (.progn (.optional (.whitespace))
                        (or end (.result nil)))))
       (.result (if first (list* first rest))))))
            
  
  
  (defun .cons ()
    (.let* ((_ (.char= #\())
            (car (.sexp))
            (_ (.dot))
            (cdr (.sexp))
            (_ (.char= #\))))
      (.result (cons car cdr))))
                  
  
  
  
#+END_SRC
#+BEGIN_QUOTE
In the usual parenthesized syntax of Lisp, an s-expression is
classically defined inductively as

 1. an atom, or
 2. an expression of the form (x . y) where x and y are s-expressions.

[...]

Most modern sexpr notations in addition use an abbreviated notation to
represent lists in s-expressions, so that

(x y z)
stands for

(x . (y . (z . NIL)))

where NIL is the special end-of-list symbol (written '() in Scheme).

-- https://en.wikipedia.org/wiki/S-expression
#+END_QUOTE



