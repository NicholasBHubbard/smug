<!DOCTYPE html>
<html lang="en"><head><title>SMUG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script type="text/javascript" src="http://orthecreedence.github.io/highlight-lisp/js/highlight-lisp/highlight-lisp.js"></script>
  <link rel="stylesheet" id="hl-theme" href="http://orthecreedence.github.io/highlight-lisp/js/highlight-lisp/themes/github.css">
  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
  
  <!-- Optional theme -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap-theme.min.css">
   
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script> 
  <!-- Latest compiled and minified JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
  
   <style>
ul.affix {
      position: fixed;
      width:23%;
 
}
ul.affix-top {
      /* position: static; */
}
ul.affix-bottom {
        /* position: absolute; */
}

/* First level of nav */
.sidenav {
  margin-top: 30px;
  margin-bottom: 30px;
  padding-top:    10px;
  padding-bottom: 10px;
  background-color: #f7f5fa;
  border-radius: 5px;
}

/* All levels of nav */
.sidebar .nav > li > a {
  display: block;
  color: #716b7a;
  padding: 5px 20px;
}
.sidebar .nav > li > a:hover,
.sidebar .nav > li > a:focus {
  text-decoration: none;
  background-color: #e5e3e9;
}
.sidebar .nav > .active > a,
.sidebar .nav > .active:hover > a,
.sidebar .nav > .active:focus > a {
  font-weight: bold;
  color: #563d7c;
  background-color: transparent;
}

/* Nav: second level */
.sidebar .nav .nav {
        display: none;
}
.sidebar .nav > li.active .nav {
        display:block;
}
.sidebar .nav .nav {
  margin-bottom: 8px;
}
.sidebar .nav .nav > li > a {
  padding-top:    3px;
  padding-bottom: 3px;
  padding-left: 30px;
  font-size: 90%;
}
 .sidebar .nav > .active > a,
.sidebar .nav > .active:hover > a,
.sidebar .nav > .active:focus > a {
  font-weight: bold;
  color: #563d7c;
  background-color: transparent;
 </style></head><body data-spy="scroll" data-target=".affix-nav"><div class="container-fluid"><div class="row"><nav class="sidebar col-md-3 affix-nav" id="affix-nav-"><ul class="nav sidenav" data-spy="affix"><li><a href="#Introduction_">Introduction </a><ul class="nav"><li><a href="#Common_Lisp">Common Lisp</a></li></ul></li><li><a href="#How_To_Combine_Parsers">How To Combine Parsers</a></li><li><a href="#Reading_Input">Reading Input</a></li><li><a href="#The_Three_Primitive_Parsers">The Three Primitive Parsers</a><ul class="nav"><li><a href="#RESULT">.RESULT</a></li><li><a href="#FAIL_">.FAIL </a></li><li><a href="#ITEM">.ITEM</a></li></ul></li><li><a href="#RUN_PARSE_FUNCALL_and_CAAR_in_disguise">RUN, PARSE: FUNCALL and CAAR in disguise</a></li><li><a href="#BIND_Our_first_primitive_combinator">.BIND: Our first primitive combinator</a><ul class="nav"><li><a href="#A_quick_word_on_monads">A quick word on monads</a><ul class="nav"><li><a href="#The_monad_laws">The monad laws</a></li></ul></li></ul></li><li><a href="#SATISFIES___the_parser_predicate">.SATISFIES  : the parser predicate</a><ul class="nav"><li><a href="#IS_and_IS-NOT">.IS and .IS-NOT</a></li><li><a href="#Example_Parsers_for_letters_and_numbers_using_SATISFIES">Example Parsers for letters and numbers using .SATISFIES</a></li></ul></li><li><a href="#PLUS_the_non-deterministic_choice_combinator">.PLUS, the non-deterministic choice combinator</a><ul class="nav"><li><a href="#Example_parsers_using_PLUS">Example parsers using PLUS</a></li><li><a href="#Efficiency_">Efficiency </a><ul class="nav"><li><a href="#TODO_Explain_more_about_FIRST">TODO Explain more about .FIRST</a></li></ul></li></ul></li><li><a href="#Syntax__LET_and_the_identity_monad">Syntax : LET* and the identity monad</a><ul class="nav"><li><a href="#LET_our_version_of_LET_like_do_notation">.LET*, our version of LET* like do notation</a></li><li><a href="#Examples_using_LET">Examples using .LET*</a></li></ul></li><li><a href="#MAP__The_repetition_combinator">.MAP : The repetition combinator</a><ul class="nav"><li><a href="#ZERO-OR-MORE">.ZERO-OR-MORE</a></li><li><a href="#ONE-OR-MORE">.ONE-OR-MORE</a></li><li><a href="#Function_MAPC_MAPCAR">Function .MAPC, .MAPCAR</a></li><li><a href="#Function_MAKE-LIST_MAKE-SEQUENCE">Function .MAKE-LIST, .MAKE-SEQUENCE</a></li><li><a href="#Function_CONCATENATE_">Function .CONCATENATE </a></li><li><a href="#MAP__ONE_FUNCTION_TO_RULE_THEM_ALL">.MAP : ONE FUNCTION TO RULE THEM ALL!</a></li><li><a href="#Examples_using_MAP">Examples using .MAP</a></li></ul></li><li><a href="#OR_NOT_and_AND__deterministic_logic_combinators">.OR, .NOT, and .AND : deterministic logic combinators</a><ul class="nav"><li><a href="#OR">.OR</a></li><li><a href="#NOT">.NOT</a></li><li><a href="#AND">.AND</a></li><li><a href="#Examples_using__OR_NOT_and_AND">Examples using  .OR, .NOT, and .AND</a><ul class="nav"><li><a href="#NO-MORE-INPUT">.NO-MORE-INPUT</a></li><li><a href="#PROGN_PROG1_PROG2">.PROGN, .PROG1, .PROG2</a></li><li><a href="#OPTIONAL">.OPTIONAL</a></li></ul></li></ul></li></ul></nav><div class="col-md-9"><div class="class"><h1>SMUG Tutorial : Literate</h1><div class="org-body"><div><!--#+TITLE: SMUG Tutorial : Literate--><p>  This tutorial started as a translation of _Monadic Parser  Combinators_ <a href="#">[1]</a>, or at least the first half, into common lisp.</p><p>  The example code in the following document is completely  self-contained, and does not require an installation of the <code>SMUG</code>  library.</p><p>  No prior experience with functional programming, monads or recursive  descent parsing is assumed. The only requirements are a common lisp  environment, and a burning desire to find a better way to parse.  </p></div></div></div><div class="org-sections"><div class="org-section" id="Introduction_"><h2 class="page-header">Introduction </h2><div class="org-body"><div><p> This tutorial, like this library, is based on an approach to building parsers using higher-order functions (combinators) that is popular in the functional programming community. Incidentally, these parsers form an instance of something called a monad, which is itself a useful construct with implications beyond parsing.</p><p> With great debt to Monadic Parser Combinators<a href="#">[fn:1]</a>, the paper from which this library is derived, this tutorial presents a step by step introduction to the topics of parser combinators and monads and their use in common lisp.</p></div></div><div class="org-section" id="Common_Lisp"><h3 class="page-header">Common Lisp</h3><div class="org-body"><div><p> In some cases, the natural name for a parser conflicts with a name in the <code>COMMON-LISP</code> package. Rather then shadow the symbols, I've chosen to prefix all parser names with a #\. character. It is thought that this aids usability, as one can simply <code>(:use :smug/tutorial)</code>. It also helps to distinguish parser returning functions from other functions.</p></div></div></div></div><div class="org-section" id="How_To_Combine_Parsers"><h2 class="page-header">How To Combine Parsers</h2><div class="org-body"><div><blockquote><pre>   A Parser for Things
   is a function from Strings
   to Lists of Pairs
   of Things and Strings!
   -- Fritz Ruehr, Willamette University [2]
</pre></blockquote><p> </p><p>   A parser is something that is familiar to all programmers... a   function that, given a series of tokens as input, produces a data   structure that relates to the grammatical structure of the input in   some way. Or, to put it simply, a function from strings to things.   </p><pre><code class="lisp">  ;; our fictional parser matches the string &quot;string&quot; 
  ;; and returns a SYMBOL thing    
  (parse-thing &quot;string&quot;) =&gt; THING
</code></pre><p>      In order to combine simple parsers into larger more complex ones,   they need a way to communicate between them. First, because any   given parser might consume only a part of the input, we'll have our   parser return a <code>CONS</code> with the result in the <code>CAR</code> and the remaining   input in the <code>CDR</code>.</p><pre><code class="lisp">     (parse-thing &quot;string string&quot;) =&gt; (THING . &quot; string&quot;)
</code></pre><p>   Because a parser may return multiple results when the   grammar is ambiguous, or may return no results all, we'll put our   conses in a list, and have the empty list, <code>NIL</code>, denote a failed   parse.</p><pre><code class="lisp">     (parse-thing &quot;string string&quot;) ;=&gt; ((THING . &quot; string&quot;))
     (parse-thing &quot;strong string&quot;) ;=&gt; NIL
</code></pre><p>  So, for our purposes, a parser is just a <code>FUNCTION</code> that takes a  single value as the input and returns a <code>LIST</code> of <code>CONS</code>'s of results  and unconsumed input.    It is this trivial protocol that allows us to combine small simple  parsers into larger more useful ones.</p></div></div></div><div class="org-section" id="Reading_Input"><h2 class="page-header">Reading Input</h2><div class="org-body"><div><p>  Smug parsers allow infinite look-ahead and backtracking. To support  parsing many different things, it's useful to define an input  protocol. Smug parsers only require three operations on input :  <code>INPUT-FIRST</code>, <code>INPUT-REST</code> and <code>INPUT-EMPTY-P</code>.  </p><p>  We'll define them in terms of strings. It serves our purposes and  makes for a nice visual presentation.</p><pre><code class="lisp">    (defgeneric input-empty-p (input)
      (:method ((input string)) (zerop (length input))))
    
    (defgeneric input-first (input)
      (:method ((input string)) (aref input 0)))
    
    (defgeneric input-rest (input)
      (:method ((input string))
        (multiple-value-bind (string displacement) 
            (array-displacement input)      
          (make-array (1- (length input))
                      :displaced-to (or string input)
                      :displaced-index-offset (1+ displacement)
                      :element-type (array-element-type input)))))
</code></pre><p>    </p><pre><code class="lisp">    (input-empty-p &quot;&quot;) =&gt; t
    (input-empty-p &quot;foo&quot;)
    (input-first &quot;foo&quot;) =&gt; #\f
    (input-rest &quot;foo&quot;) =&gt; &quot;oo&quot;
</code></pre></div></div></div><div class="org-section" id="The_Three_Primitive_Parsers"><h2 class="page-header">The Three Primitive Parsers</h2><div class="org-body"><div><p>  There are 3 simple primitive parsers. It it only necessary to  understand them, and one sequencing combinator, <code>.BIND</code>, to understand  all of <code>SMUG/TUTORIAL</code>.</p></div></div><div class="org-section" id="RESULT"><h3 class="page-header"><code>.RESULT</code></h3><div class="org-body"><div><p>    The first parser is <code>.RESULT</code>, which always succeeds by returning the    value passed to it,  and does not consume any input. Because we've    earlier defined parsers as functions that take a single argument    we'll make a curry<a href="#">[5]</a> with the input parameter.</p><!--#+NAME: tutorial_.result--><pre><code class="lisp">  (defun .result (value)
    (lambda (input)
      (list (cons value input))))
</code></pre><!--#+NAME: tutorial-test_.result--><pre><code class="lisp">  (test&gt; (funcall (.result :foo) &quot;bar baz&quot;)
         =&gt; ((:foo . &quot;bar baz&quot;)))
</code></pre></div></div></div><div class="org-section" id="FAIL_"><h3 class="page-header"><code>.FAIL</code> </h3><div class="org-body"><div><p>    The second parser, <code>.FAIL</code>, is the inverse behaviour of    <code>.RESULT</code>. It simply fails regardless of the input. we could    define <code>.FAIL</code> as a function that takes a single argument, but then    we'd have to access it using <code>FUNCTION</code> (#'), and aesthetically that    inconsistency is undesirable, so we'll again make curry with the    input parameter.</p><!--#+NAME: tutorial_.fail--><pre><code class="lisp">(defun .fail ()
  (lambda (input) (declare (ignore input)) nil))
</code></pre><!--#+NAME: tutorial-test_.fail--><pre><code class="lisp">(test&gt; (funcall (.fail) &quot;foo&quot;) =&gt; NIL)
</code></pre></div></div></div><div class="org-section" id="ITEM"><h3 class="page-header"><code>.ITEM</code></h3><div class="org-body"><div><p>    The last true primitive is .<code>.ITEM</code>, which is a parser that    consumes the first token in the input, or fails in the input is    empty.</p><!--#+NAME: tutorial_.item--><pre><code class="lisp">(defun .item ()
  (lambda (input)
    (unless (input-empty-p input)
      (list (cons (input-first input)
		  (input-rest input))))))
</code></pre><!--#+NAME: tutorial-test_.item--><pre><code class="lisp">  (test&gt; (funcall (.item) &quot;foo&quot;) 
         =&gt; ((#\f . &quot;oo&quot;)))

  (test&gt; (funcall (.item) &quot;&quot;) 
         =&gt; NIL)
</code></pre></div></div></div></div><div class="org-section" id="RUN_PARSE_FUNCALL_and_CAAR_in_disguise"><h2 class="page-header"><code>RUN</code>, <code>PARSE</code>: <code>FUNCALL</code> and <code>CAAR</code> in disguise</h2><div class="org-body"><div><p>All the primitives return a <code>FUNCTION</code> that must be <code>FUNCALL</code>'ed with <code>INPUT</code> inorder to run the parser. </p><p>There are many reasons to define a <code>RUN</code> function. We can <code>CL:TRACE</code>it, or change the input parameter <code>TYPE</code>, or change what the actualprimitives return.</p><!--#+NAME: tutorial_run--><pre><code class="lisp">  (defun run (parser input)
    (funcall parser input))
</code></pre><p>The <code>RUN</code> function returns the entire parse tree. Most of the time wesimply want the <code>CAR</code> of the <code>FIRST</code> result. The <code>CDR</code> is the leftoverinput, and the <code>REST</code> of the result alternative outcomes. We mightwant these as well, so we return the as <code>VALUES</code>.</p><!--#+NAME: tutorial_run--><pre><code class="lisp">  (defun parse (parser input)
    (let ((result (run parser input)))
      (when result 
        (destructuring-bind ((result . input) &amp;rest rest)
            result      
          (apply #'values result input rest)))))
</code></pre><!--#+RESULTS: tutorial_run--><p>: PARSE</p></div></div></div><div class="org-section" id="BIND_Our_first_primitive_combinator"><h2 class="page-header"><code>.BIND</code>: Our first primitive combinator</h2><div class="org-body"><div><p>   Now that we have our primitive parsers, we need a way to combine   them. We'd like to be able to apply parsers in sequence, and it   would also come in handy if we could give names to the intermediate   results of parsers. Both these requirements are fulfilled by using   the monadic sequencing operator, <code>.BIND</code>.</p><p>   <code>.BIND</code> is a function that takes as arguments a parser P, and a   function F which take a value and returns a parser P2. <code>.BIND</code> returns   a parser that first applies P to the input, returning a list of   <code>(VALUE . INPUT)</code> pairs. The the function ~F~ is applied to each <code>VALUE</code>,   and the result <code>P2</code> then applied to the <code>INPUT</code>. The collected lists of   pairs returned from the <code>P2</code>'s are then concatenated and the result   returned.</p><!--#+NAME: tutorial_.bind--><pre><code class="lisp">  (defun .bind (parser function)
    (lambda (input)
      (loop :for (value . input) :in (run parser input)
            :append (run (funcall function value) input))))
</code></pre><!--#+NAME: tutorial-test_.bind--><pre><code class="lisp">  (let ((char-token
         (.bind (.item) 
               (lambda (char) 
                 (.result (list :char char))))))           
    (run char-token &quot;foo&quot;))
  ;; ~&gt; (((:CHAR #\f) . &quot;oo&quot;))
</code></pre><p>   Because <code>.BIND</code> itself returns a parser, the result of a <code>.BIND</code> can be   returned as P2. This allows parsers to be chained, and allows us to   use <code>LAMBDA</code> to provide names for the values of parser results. For   example, the following parser uses <code>.BIND</code> to return the first two   characters as a cons.</p><pre><code class="lisp">(let ((two-chars 
       (.bind (.item) 
	     (lambda (char) 
	       (.bind (.item) 
		     (lambda (char2) 
		       (.result (cons char char2))))))))
  (run two-chars &quot;asd&quot;))
;;=&gt; (((#\a . #\s) . &quot;d&quot;))
</code></pre><p>   The next section gets into some details about why our parser is a   monad.  You don't really need to know this, so feel free to [[**Some%20Parsers%20Using%20Bind][skip it]]   if you're in a hurry.</p></div></div><div class="org-section" id="A_quick_word_on_monads"><h3 class="page-header">A quick word on monads</h3><div class="org-body"><div><p>   By virtue of having the functions <code>.BIND</code> and <code>.RESULT</code> defined as they   are, our parser interface forms a monad. A monad is, essentially,   a category of things that provide the functions <code>.BIND</code> and <code>.RESULT</code>.      Of course, just having functions called <code>.BIND</code> and <code>.RESULT</code> does not a   monad make. There are other contracts that <code>.BIND</code> (also known as   pipe, &gt;&gt;~, *, or let) or <code>.RESULT</code> (aka lift, unit, return) must   fulfill.</p></div></div><div class="org-section" id="The_monad_laws"><h4 class="page-header">The monad laws</h4><div class="org-body"><div><p>    In order to be properly categorized as a monad, the thing    providing a definition for <code>.BIND</code> and <code>.RESULT</code> must obey three laws    (a static functional programmer would say 'must have a certain    type', but the word type means something different to a dynamic    functional programmer, so we'll avoid it here)</p><p>    In order to describe those laws we need to define a few terms</p><p>    - Monadic Value (MV) :: a function that, given a value, returns a	 value in the form expected by the internals of <code>.BIND</code>. In our	 examples above, a parser (taking an input and returning a	 list of results) is the Monadic Value.</p><p>    - Monadic Function (MF) :: A function that, given a value returns	 a monadic value encapsulating that value. <code>.RESULT</code> is the	 canonical Monadic Function        In Object-Oriented terms, the MF is a constructor, and the MV an    object.</p><p>    The laws which all things must obey in order to be called a monad    are simple :</p><p>    - &quot;Left identity&quot; ::  (bind (result x) MF) = (funcall MF x)</p><p>    - &quot;Right identity&quot; :: (bind MV result) = MV</p><p>    - &quot;Associativity&quot; ::  (bind (bind MV MF) MF2) 	 = (bind MV (lambda (x) (bind (MF x) MF2)))        With static type systems, the compiler will enforce this contract    for you. In a dynamic system, we just need to be a little more    careful. Proving the monad laws for our <code>.BIND</code> and <code>.RESULT</code> is    left as an exercise.</p><p>    That's really all there is to monads except for syntax, which    we'll get to later. There are extended laws that other monads    obey, and monads have other uses beyond parsing, but we're    reaching the end of our scope already.</p></div></div></div></div></div><div class="org-section" id="SATISFIES___the_parser_predicate"><h2 class="page-header"><code>.SATISFIES</code>  : the parser predicate</h2><div class="org-body"><div><p>    Often, we only want to consume input if a certain    condition is true. This where <code>.SATISFIES</code> comes in.</p><!--#+NAME: tutorial_.satisfies--><pre><code class="lisp">(defun .satisfies (predicate &amp;rest args)
  (.bind (.item) 
	(lambda (x) 
	  (if (apply predicate x args)
	      (.result x)
	      (.fail)))))
</code></pre><p>#+RESULTS:: TEST&gt;</p><!--#+NAME: tutorial-test_.satisfies--><pre><code class="lisp">(run (.satisfies #'digit-char-p) &quot;1 and&quot;) 
;;=&gt; ((#\1 . &quot; and&quot;))
</code></pre><p>   If <code>.ITEM</code> fails, so will the <code>.SATISFIES</code> parser. This is because (bind   (fail) MF) will always fail. <code>.FAIL</code>, also known as <code>.ZERO</code>, is a function   belonging to a category of monads knows as &quot;monads with a   zero&quot;. That's not terribly important for parsing, but interesting if   you're into that sort of thing.</p></div></div><div class="org-section" id="IS_and_IS-NOT"><h3 class="page-header"><code>.IS</code> and <code>.IS-NOT</code></h3><div class="org-body"><div><p>Imagine we need to parse all characters that come before a <code>#\;</code>. Thesimple way is to have a function that uses <code>CL:NOT</code>.</p><pre><code class="lisp">  (.satisfies 
   (lambda (item)
     (not (char= #\; item))))
</code></pre><p>It turns out that <code>(.satisfies (lambda (i) (not ...)))</code> is quitecommon, so we define a parser that has a shorter and more relevantname.</p><!--#+NAME: tutorial_.is-not--><pre><code class="lisp">(defun .is-not (predicate &amp;rest args)
  (.satisfies (lambda (i) 
                 (cl:not (apply predicate i args)))))
</code></pre><p>This makes things a lot shorter and easier to read.</p><!--#+NAME: tutorial_test.is-not --><pre><code class="lisp">  (test&gt; 
   (run (.is-not #'char= #\;) &quot;foobar;%^*&amp;&quot;)       
   =&gt; ((#\f . &quot;oobar;%^*&amp;&quot;)))
</code></pre><!--#+NAME: tutorial_test.is-not --><pre><code class="lisp">  (test&gt; 
   (run (.is-not #'char= #\;) &quot;;%^*&amp;&quot;)
   =&gt; NIL)
</code></pre><p>For that matter, now that we have <code>.IS-NOT</code>, <code>.SATISFIES</code> is a bitlong, and does not prefix <code>-NOT</code> . So we type a few keys inorder to save a bundle in the future.</p><!--#+NAME: tutorial_.is--><pre><code class="lisp">  (defun .is (predicate &amp;rest args)
    (apply #'.satisfies predicate args))
</code></pre></div></div></div><div class="org-section" id="Example_Parsers_for_letters_and_numbers_using_SATISFIES"><h3 class="page-header">Example Parsers for letters and numbers using <code>.SATISFIES</code></h3><div class="org-body"><div><p>     <code>.SATISFIES</code> allows us to <code>DEFUN</code> some simple parsers</p><!--#+NAME: tutorial_char=digit-char|lower-case-p--><pre><code class="lisp">  (defun .char= (x)
    (.is #'cl:char= x))
  
  (defun .digit-char-p ()
    (.is #'cl:digit-char-p))
  
  (defun .lower-case-p ()
    (.is #'cl:lower-case-p))
  
  (defun .upper-case-p ()
    (.is #'cl:upper-case-p))  
</code></pre><!--#+NAME: tutorial-test_char=digit-char|lower-case-p--><pre><code class="lisp">  (run (.char= #\x) &quot;xyzzy&quot;) ;=&gt; ((#\x . &quot;yzzy&quot;))
  (run (.digit-char-p) &quot;1234&quot;) ;=&gt; ((#\1 . &quot;234&quot;))
  (run (.lower-case-p) &quot;abcd&quot;) ;=&gt; ((#\a . &quot;bcd&quot;))
  (run (.upper-case-p) &quot;Abcd&quot;) ;=&gt; ((#\A . &quot;bcd&quot;))  
  (run (.upper-case-p) &quot;doh!&quot;) ;=&gt; NIL

</code></pre></div></div></div></div><div class="org-section" id="PLUS_the_non-deterministic_choice_combinator"><h2 class="page-header"><code>.PLUS</code>, the non-deterministic choice combinator</h2><div class="org-body"><div><p>   If we want to combine our earlier parsers, say to create an   <code>ALPHANUMERIC-CHAR</code> from <code>UPPER-CASE-P</code> and <code>LOWER-CASE-P</code> we need   a combinator capable of making the choice between them.</p><p>   In some cases, it may not be an exclusive choice. There might be   multiple ways to parse a string, or a later pass might resolve the   ambiguity.</p><p>   For example, in one of our earlier examples of <code>.BIND</code>, we saw a   parser that returned the first two characters in a stream. This   parser will fail if there is only one character left in the input.</p><pre><code class="lisp">(let ((two-chars 
       (.bind (.item) 
	     (lambda (char) 
	       (.bind (.item) 
		     (lambda (char2) 
		       (.result (cons char char2))))))))
  (funcall two-chars &quot;a&quot;))
;;=&gt; NIL
</code></pre><p>  </p><p>  If we want to parse one or two characters, or an arbitrarily long  series of characters, we need some a way to express that.</p><p>  Enter the <code>.PLUS</code> combinator.</p><!--#+NAME: tutorial_.plus--><pre><code class="lisp">  (defun .plus (first-parser second-parser)
    (lambda (input)
      (append (funcall first-parser input) (funcall second-parser input))))
</code></pre><!--#+NAME: tutorial-test_.plus--><pre><code class="lisp">  (let ((two-chars 
         (.bind (.item) 
               (lambda (char) 
                 (.bind (.item) 
                       (lambda (char2) 
                         (.result (cons char char2))))))))
    (funcall (.plus two-chars (.item)) &quot;a&quot;) 
    ;;=&gt; ((#\a . &quot;&quot;)) 
    (funcall (.plus two-chars (.item)) &quot;asd&quot;)
    ;;=&gt; (((#\a . #\s) . &quot;d&quot;) (#\a . &quot;sd&quot;))
    )
</code></pre><p>  Note that the second parse returned two pairs, as both parsers were  successful. The string parsed as both two chars and a single item.</p></div></div><div class="org-section" id="Example_parsers_using_PLUS"><h3 class="page-header">Example parsers using PLUS</h3><div class="org-body"><div><p>    The examples used in the original paper<a href="#">[1]</a> are for letters and    alphanumeric characters. There's no good reason to use them over    <italic>(.is #'alpha-char-p)</italic>and the like, but they do serve as     simple example.</p><pre><code class="lisp">(defun letter () (plus (lower-case-char) (upper-case-char)))

(funcall (letter) &quot;foo&quot;) =&gt; ((#\f . &quot;oo&quot;))
(funcall (letter) &quot;1foo&quot;) =&gt; NIL

(defun alphanumeric () (plus (letter) (.digit-char)))

(funcall (alphanumeric) &quot;1foo&quot;) =&gt; ((#\1 . &quot;foo&quot;))
(funcall (alphanumeric) &quot;!1foo&quot;) =&gt; NIL
</code></pre><p>  The other example is more illustrative, a parser that returns a  series of letters or the empty string.</p><pre><code class="lisp">(defun word ()
  (let ((non-empty-letters 
	 (bind (letter) 
	       (lambda (first-letter) 
		 (bind (word)
		       (lambda (rest-of-letters)
			 (result (format nil &quot;~A~A&quot; 
					 first-letter
					 rest-of-letters))))))))
    (plus non-empty-letters (result &quot;&quot;))))

(funcall (word) &quot;asd&quot;)
=&gt;
((&quot;asd&quot; . &quot;&quot;) (&quot;as&quot; . &quot;d&quot;) (&quot;a&quot; . &quot;sd&quot;) (&quot;&quot; . &quot;asd&quot;))

</code></pre><p>  This is our first recursive parser, but it's a common idiom. Notice  that it returns all the possible strings of letters. </p><p>  This is obviously inefficient when one only requires the first value.  required, a deterministic combinator <code>.OR</code>, will be introduced later  in the tutorial.</p></div></div></div><div class="org-section" id="Efficiency_"><h3 class="page-header">Efficiency </h3><div class="org-body"><div><p>   <code>.FIRST</code> is the real choice when it comes down to it, as <code>.PLUS</code> really does matter.</p><!--#+NAME: tutorial_.first--><pre><code class="lisp">(defun .first (parser)
  (lambda (input)
    (let ((results (run parser input)))
       (when results (list (cl:first results))))))
</code></pre></div></div><div class="org-section" id="TODO_Explain_more_about_FIRST"><h4 class="page-header">TODO Explain more about <code>.FIRST</code></h4><div class="org-body"><div><p>   </p></div></div></div></div></div><div class="org-section" id="Syntax__LET_and_the_identity_monad"><h2 class="page-header">Syntax : <code>LET*</code> and the identity monad</h2><div class="org-body"><div><p>   If you read the earlier section on monads, you'd know that <code>.BIND</code>   and <code>.RESULT</code> are the interface to many different types of monads,   of which our parser is but one example. If you didn't, you know   now. Again, if you're not at all interested and really just want to   keep on parsing, [[%20defmacro%20letstar][skip down to the macro]]. </p><p>   The most basic monad is the identity monad. A definition of its   <code>.BIND</code> and <code>.RESULT</code> might look like the following.</p><pre><code class="lisp">
(defun i-bind (mv mf) (funcall mf mv))
(defun i-result (value) value)

</code></pre><p>    In Lisp, the identity monad is so trivial as to be useless. In a    functional programming language, or any language where the order    of operations is not guaranteed, the identity monad serves to    sequence operations.</p><p>    Imagine a silly lisp where the order of evaluation isn't defined    as strict left to right<a href="#">[3]</a>. The following form could have    disastrous consequences.</p><pre><code class="lisp">
(progn (remove-gun-from-pants)
       (point-gun-at-bad-guy)
       (pull-trigger))

</code></pre><p>   The identity monad makes the sequencing explicit. In a purely   functional lisp, one might sequence the operations as follows.</p><pre><code class="lisp">(i-bind (remove-gun-from-pants) 
      (lambda (gun)
	(i-bind (point-gun-at-bad-guy gun)
	      (lambda (pointed-gun)
	      (i-bind (pull-trigger pointed-gun)
		      (lambda (fired-gun)
			(i-result fired-gun)))))))
</code></pre><p>   In functional programming languages this pattern is so common that   there is special syntax for it. The usual choices are 'do notation'   or 'list comprehension syntax'.</p><p>   First, the previous example rendered in list comprehension   notation :</p><pre><code class="haskell">[fgun | gun &lt;- removeGun 
      , pgun &lt;- pointGunAtBadGuy gun
      , fgun &lt;- pullTrigger pgun] 
        
</code></pre><p>   And in do notation :</p><pre><code class="haskell">do 
  gun &lt;- removeGun 
  pgun &lt;- pointGunAtBadGuy
  fgun &lt;- pullTrigger pgun
  return fgun
</code></pre><p>   The astute lisper might notice that do notation looks a lot like   LET<bold>. In fact, that's really all it is. LET</bold> is lisp syntax for the   identity monad, and our i-bind using forms above are directly   translatable.</p><pre><code class="lisp">(let* ((gun (remove-gun-from-pants))
       (pointed-gun (point-gun-at-bad-guy gun))
       (fired-gun (pull-trigger pointed-gun)))
  (identity fired-gun))
</code></pre><p>  One could legitimately say that the common lisp package is an  instance of the identity monad, if one cared for such insights.</p></div></div><div class="org-section" id="LET_our_version_of_LET_like_do_notation"><h3 class="page-header"><code>.LET*</code>, our version of <code>LET*</code> like do notation</h3><div class="org-body"><div><p># &lt;&lt; defmacro letstar &gt;&gt;</p><p>    A <code>LET*</code> like construct is the obvious notation for a lisper to take    advantage of the monadic nature of parsers. It's often useful to    ignore a value. In haskell, the underscore character is used to    denote an ignorable variable, so we'll use the same convention.</p><!--#+NAME: tutorial_.letstar--><pre><code class="lisp">  (defmacro .let* (bindings &amp;body body)
    (if bindings
        (let ((symbol (first (first bindings))))
          `(.bind ,@(cdr (first bindings))
                 (lambda (,symbol)
                   ,@(when (string-equal (symbol-name symbol) &quot;_&quot;)
                           `((declare (ignorable ,symbol))))
                   (.let* ,(cdr bindings)
                     ,@body))))
        `(progn ,@body)))
</code></pre><pre><code class="lisp">  (funcall (.let* ((a (.result 1)))
             (.result a)) &quot;&quot;)
</code></pre><p>If we replace <code>.BIND</code> with our <code>I-BIND</code> function above, we get a macrothat is equivalent to <code>LET*</code>. <code>.LET*</code> binds the results of parsers,and is a much nicer way to work over nesting <code>.BIND</code>'s.</p></div></div></div><div class="org-section" id="Examples_using_LET"><h3 class="page-header">Examples using <code>.LET*</code></h3><div class="org-body"><div><p>    Using recursion like we did in our WORD parser, we'll create a    parser that matches a specific string.</p><p># &lt;&lt; tutorial_.string= &gt;&gt;</p><!--#+NAME: tutorial_.string=--><pre><code class="lisp">  (defun .string= (string)
    (if (string= string &quot;&quot;)
        (.result nil)
        (.let* 
            ((_ (.is 'char= (aref string 0)))
             (_ (.string= (subseq string 1))))
          (.result string))))
</code></pre><!--#+NAME: tutorial-test.string=--><pre><code class="lisp">(run (.string= &quot;asdf&quot;)  &quot;asdfjkl&quot;) =&gt; ((&quot;asdf&quot; . &quot;jkl&quot;))
</code></pre><pre><code class="lisp">(run (.string= &quot;asdf&quot;)  &quot;asd&quot;) =&gt; NIL
</code></pre><p>    Once can see how much nicer <code>.LET*</code> notation is, and also how the    ignorable ~_~ comes in handy. </p></div></div></div></div><div class="org-section" id="MAP__The_repetition_combinator"><h2 class="page-header"><code>.MAP</code> : The repetition combinator</h2><div class="org-body"><div><p>      Earlier, we defined a parser, <code>.WORD</code>, using <code>.BIND</code> and a recursive   call. Lets define a similar parser using <code>.LET*</code> that returns a list   of letters.</p><pre><code class="lisp">  (defun .letters ()
    (.plus (.let* ((x (.letter))
                 (xs (.letters)))
           (.result (cons x xs)))
         (.result nil)))
</code></pre><p>   This pattern can easily be abstracted into a more general   combinator, <code>.ZERO-OR-MORE</code></p></div></div><div class="org-section" id="ZERO-OR-MORE"><h3 class="page-header"><code>.ZERO-OR-MORE</code></h3><div class="org-body"><div><pre><code class="lisp">  (defun .zero-or-more (parser)
    (.plus (.let* ((x parser)
                   (xs (.zero-or-more parser)))
             (.result (cons x xs)))
           (.result ())))
</code></pre><pre><code class="lisp">  (test&gt; 
   (run (.zero-or-more (.char= #\a)) &quot;aaaab&quot;
   =&gt;  (((#\a #\a #\a #\a) . &quot;b&quot;) ((#\a #\a #\a) . &quot;ab&quot;) ((#\a #\a) . &quot;aab&quot;)
        ((#\a) . &quot;aaab&quot;) (NIL . &quot;aaaab&quot;)))
  
  (test&gt; 
   (run (.zero-or-more (.char= #\a)) &quot;bbbba&quot;)
   =&gt;
   ((NIL . &quot;bbbba&quot;)))
</code></pre><p>   Note that zero or more always succeeds. If one needs a parser that   matches one or more items and fails otherwise, we can define one in   terms of ZERO-OR-MORE, can call it, appropriately enough,   ONE-OR-MORE.</p></div></div></div><div class="org-section" id="ONE-OR-MORE"><h3 class="page-header"><code>.ONE-OR-MORE</code></h3><div class="org-body"><div><pre><code class="lisp">(defun .one-or-more (parser)
  (.let* ((x parser)
	  (y (.zero-or-more parser)))
    (.result (cons x y))))

(test&gt; (funcall (.one-or-more (.char= #\a)) &quot;aaaab&quot;)
  =&gt;
 (((#\a #\a #\a #\a) .many &quot;b&quot;)))

(test&gt; (funcall (.one-or-more (.char= #\a)) &quot;bbbba&quot;)
   =&gt; NIL)
</code></pre><p>We could now define a <code>TWO-OR-MORE</code> and <code>THREE-OR-MORE</code> etc., but itis likely better to define a function to rule them all. It needs abase to rule from.</p></div></div></div><div class="org-section" id="Function_MAPC_MAPCAR"><h3 class="page-header"><italic>Function</italic> <code>.MAPC</code>, <code>.MAPCAR</code></h3><div class="org-body"><div><p># <code>.MAPCAN</code>, <code>.MAPL</code>, <code>.MAPLIST</code>, <code>.MAPCON</code></p><p><bold>Syntax:</bold></p><p><code>.mapc</code> <italic>parser</italic>  =&gt; <italic>parser</italic></p><p><code>.mapcar</code> <italic>parser</italic> =&gt; <italic>result-list</italic></p><p># mapcan function &amp;rest lists+ =&gt; concatenated-results</p><p># mapl function &amp;rest lists+ =&gt; list-1</p><p># maplist function &amp;rest lists+ =&gt; result-list</p><p># mapcon function &amp;rest lists+ =&gt; concatenated-results</p><p><bold>Arguments and Values:</bold></p><p> - <italic>parser</italic> :: The parser that is attempted - <italic>result-list</italic> :: a list</p><p><bold>Description:</bold> </p><p>The mapping operation involves attempting <italic>parser</italic> many times. Exceptfor <code>.mapc</code> and <code>.mapl</code>, the result contains the results returned bythe <italic>parser</italic>. </p><p># In the cases of mapc and mapl, the resulting sequence is list.</p><p><code>.MAPCAR</code> operates on successive results of <italic>parser</italic>. The iterationterminates when the <italic>parser</italic> fails. The value returned by mapcar is alist of the results of <italic>parser</italic></p><!--#+name: tutorial-.mapcar--><pre><code class="lisp">(defun .mapcar (parser)
    (.plus (.let* ((x parser)
                   (xs (.mapcar parser)))
             (.result (cons x xs)))
           (.result ())))
</code></pre><p>#+RESULTS:: \.MAPCAR</p><p><code>.MAPC</code> is like <code>.MAPCAR</code> except that the results of applying function arenot accumulated. The <italic>parser</italic> argument is returned as a result.</p><!--#+name: tutorial-.mapc--><pre><code class="lisp">(defun .mapc (parser)
    (.plus (.let* ((_ parser)
                   (_ (.mapc parser)))
             (.result parser))
           (.result parser)))
</code></pre><p>#+RESULTS:: \.MAPC</p><p><bold>Examples:</bold></p><pre><code class="lisp">   
   (test&gt; (parse (.prog1 (.mapcar (.item))
                          (.char= #\!))
                  &quot;Yay!&quot;)
     =&gt; (#\Y #\a #\y))
 
</code></pre><pre><code class="lisp">  (let ((/parser/ (.item)))
    (test&gt; (parse (.let* ((parser (.prog1 (.mapc /parser/)
                                          (.char= #\!)))
                          (char parser))
                    (.result (cons (eq parser /parser/)
                                   char)))
                  &quot;Holy Guacamole!?&quot;)
           =&gt;(T . #\?)))                       
</code></pre></div></div></div><div class="org-section" id="Function_MAKE-LIST_MAKE-SEQUENCE"><h3 class="page-header"><italic>Function</italic> <code>.MAKE-LIST</code>, <code>.MAKE-SEQUENCE</code></h3><div class="org-body"><div><p>Often, we know what we want, and how many we want, all at once. So,just like <code>CL:MAKE-LIST</code>, we take a number.</p><p><bold>Syntax:</bold></p><p><code>.make-list</code> <italic>size</italic> <italic>&amp;key</italic> <italic>initial-element</italic> =&gt; <italic>list</italic></p><p><code>.make-sequence</code> <italic>result-type</italic> <italic>size</italic> <italic>&amp;key</italic> <italic>initial-element</italic> =&gt; <italic>list</italic></p><p><bold>Arguments and Values:</bold></p><p> - <italic>size</italic> :: a non-negative integer.</p><p> - <italic>initial-element</italic> :: a <italic>parser</italic>. The default is <code>(.item)</code>.</p><p> - <italic>list</italic> :: a list.</p><p><bold>Description:</bold></p><p>Returns a <italic>list</italic> of <italic>length</italic> given by <italic>size</italic>, each of the elements ofwhich is a successful run of the <italic>initial-element</italic> parser.</p><!--#+name: tutorial-.make-list--><pre><code class="lisp">  (defun .make-list (size &amp;key (initial-element (.item)))
    (if (zerop size) 
        (.result nil)
        (.let* ((first initial-element)
                (rest (.make-list (1- size) 
                                  :initial-element initial-element)))
          (.result (list* first rest)))))               
</code></pre><!--#+name: tutorial-.make-sequence--><pre><code class="lisp">  (defun .make-sequence (type length &amp;key (initial-element (.item)))
    (.let* ((list (.make-list length :initial-element initial-element)))
      (.result (coerce list type))))               
</code></pre></div></div></div><div class="org-section" id="Function_CONCATENATE_"><h3 class="page-header"><italic>Function</italic> <code>.CONCATENATE</code> </h3><div class="org-body"><div><p>There are often mulitple parsers that are run one after another, andthe results joined together at the end. <code>.CONCATENATE</code> takes care ofthat.</p><!--#+NAME: tutorial-.concatenate--><pre><code class="lisp">  (defun .concatenate (output-type-spec &amp;rest parsers)
    (if (not parsers)
        (.fail)
        (.let* ((first (first parsers))
                (rest (if (rest parsers)
                          (apply 
                           #'.concatenate output-type-spec (rest parsers))
                          (.result nil))))
          (.result (cl:concatenate output-type-spec first rest)))))
  
</code></pre></div></div></div><div class="org-section" id="MAP__ONE_FUNCTION_TO_RULE_THEM_ALL"><h3 class="page-header"><code>.MAP</code> : ONE <italic>FUNCTION</italic> TO RULE THEM ALL!</h3><div class="org-body"><div><p>In the end</p><p>The <code>:AT-LEAST</code> keyword solves the &quot;how many do we want to startwith?&quot;. We have decided on ~1~ as the default, as most of the time wedo want the parser to succeed, and besides that, <code>.OPTIONAL</code> is abetter way of saying <code>:at-least 0</code>.</p><p># There is also the simple matter of using <code>.PLUS</code># or <bold>&lt;whatever&gt;</bold>. The <code>:USING</code> argument takes care of that.</p><p>So, we can specify the <code>.MAP</code> parser as follows.</p><!--#+NAME: tutorial_.map--><pre><code class="lisp">  (defun .map (result-type parser
               &amp;key 
                 (at-least 1))
    &quot;=&gt; a ~result-type~ of /parser/ results.&quot;
    (.let* ((list-1 (.make-list at-least :initial-element parser))
            (list-2 (funcall (if result-type #'.mapcar #'.mapc) parser)))
      (.result (when result-type (concatenate result-type list-1 list-2)))))
</code></pre><!--#+RESULTS: tutorial_.map--><p>: \.MAP</p></div></div></div><div class="org-section" id="Examples_using_MAP"><h3 class="page-header">Examples using <code>.MAP</code></h3><div class="org-body"><div><p>    Let's make a parser for standard quoted strings. We'll use    the #\' character as the quotes, and the #\| character as the    escape character, simply to make it easier to embed in our example    text in common lisp strings.</p><pre><code class="lisp">  (defun .quoted-string (&amp;key (quote #\')
                           (escape #\|))
    (.let* ((_ (.char= quote))
            (string 
             (.map 'string 
                   (.plus (.let* ((_ (.char= escape)))
                            (.item))
                          (.is-not 'char= quote))))
            (_ (.char= quote)))
      (.result string)))
  
  
</code></pre><p>| (The quote char is ' and the escape char is | . . '') |</p></div></div></div></div><div class="org-section" id="OR_NOT_and_AND__deterministic_logic_combinators"><h2 class="page-header"><code>.OR</code>, <code>.NOT</code>, and <code>.AND</code> : deterministic logic combinators</h2><div class="org-body"><div></div></div><div class="org-section" id="OR"><h3 class="page-header"><code>.OR</code></h3><div class="org-body"><div><p>   <code>.OR</code> is a deterministic <code>.PLUS</code>. It take any number of parsers. The   first parser is run, and if it succeeds, evaluation short circuits   and the result of the parser is returned. Otherwise, the next   parser is run, and so on, until one succeeds or there are no more   parsers.       We can't use <code>.BIND</code> or <code>.LET*</code> for <code>.OR</code> because it would fail if one of   its parsers fails. As such, <code>.OR</code> must be a primitive.</p><!--#+NAME: tutorial_.or--><pre><code class="lisp">(defun .or (parser &amp;rest parsers)
  (lambda (input)
    (or (funcall parser input) 
	(when parsers 
	  (funcall (apply #'.or parsers) input)))))
</code></pre></div></div></div><div class="org-section" id="NOT"><h3 class="page-header"><code>.NOT</code></h3><div class="org-body"><div><p>   Similarly, <code>.NOT</code>, which continues parsing only when the parser   fails, is primitive as well.</p><!--#+NAME: tutorial_.not--><pre><code class="lisp">(defun .not (parser)
  (lambda (input)
    (let ((result (funcall parser input)))
      (if result
	  nil
	  (list (cons t input))))))
</code></pre></div></div></div><div class="org-section" id="AND"><h3 class="page-header"><code>.AND</code></h3><div class="org-body"><div><p>   On the other hand, <code>.AND</code> can be defined in terms of <code>IF</code>, and   doesn't even need to test for failure, as <code>.BIND</code> handles failure   automatically.</p><p>   <code>.AND</code> (known as '&gt;&gt;' in haskell) sequentially composes parsers,   discarding the results of all but the last one, and returning that   result.</p><!--#+NAME: tutorial_.and--><pre><code class="lisp">(defun .and (p1 &amp;rest ps)
  (.let* ((result p1))
    (if ps
	(apply #'.and ps)
	(.result result))))

</code></pre></div></div></div><div class="org-section" id="Examples_using__OR_NOT_and_AND"><h3 class="page-header">Examples using  <code>.OR</code>, <code>.NOT</code>, and <code>.AND</code></h3><div class="org-body"><div></div></div><div class="org-section" id="NO-MORE-INPUT"><h4 class="page-header"><code>.NO-MORE-INPUT</code></h4><div class="org-body"><div><p>    Now that we have <code>.NOT</code>, we can specifically test for failure rather    than abort the parse entirely. since the primitive parser <code>.ITEM</code>    only fails when the input is empty, we can define <code>.NO-MORE-INPUT</code> by    negating it.</p><p>#+name:tutorial_.no-more-input</p><pre><code class="lisp">  (defun .no-more-input ()
   (.not (.item)))
</code></pre></div></div></div><div class="org-section" id="PROGN_PROG1_PROG2"><h4 class="page-header"><code>.PROGN</code>, <code>.PROG1</code>, <code>.PROG2</code></h4><div class="org-body"><div><p>    Using <code>.AND</code>, we can implement <code>.PROGN</code> (which is really just    <code>.AND</code> because it will fail when the parser does), <code>.PROG1</code> (which    comes in handy for matching things and the end of the line, or    when there is no more input) and <code>.PROG2</code>, which as we will see is    also quite useful.</p><!--#+NAME: tutorial_.progn    --><pre><code class="lisp">  (defun .progn (&amp;rest parsers)
    (apply #'.and parsers))
  
  (defun .prog1 (parser &amp;rest parsers)
    (.let* ((result parser)
            (_ (apply #'.and parsers)))
      (.result result)))
  
  (defun .prog2 (parser1 parser2 &amp;rest parsers)
    (.and parser1 (apply #'.prog1 parser2 parsers)))
</code></pre></div></div></div><div class="org-section" id="OPTIONAL"><h4 class="page-header"><code>.OPTIONAL</code></h4><div class="org-body"><div><p>  The OPTIONAL combinator, which allows a parser to fail and still  continue, is a natural use of <code>.OR</code>.  </p><!--#+NAME: tutorial_.optional--><pre><code class="lisp">  (defun .optional (parser)
    (.or parser (.result nil)))
</code></pre><p>  Finally, using <code>.OR</code>, <code>.AND</code> and <code>.NOT</code>, we can make parser versions of  the lisp conditionals we all know and love.</p><pre><code class="lisp">  
  (defun .if (test-parser then-parser 
              &amp;optional (else-parser (.fail)))
    (let ((no (gensym)))
      (.let* ((no? (.or test-parser (.result no))))
        (if (not (eq no? no))
            then-parser
            else-parser))))
  
  (defun .when (test-parser then-parser)
     &quot;we define .when in terms of .IF, but it's really just .AND again&quot;
    (.if test-parser then-parser))
  
  (defun .unless (test-parser then-parser)
     &quot;defined in term of .when, even though it's just (.AND (.NOT ...))&quot;
    (.when (.not test-parser) then-parser))
  
</code></pre><p>    </p></div></div></div></div></div></div></div></div></div><script>HighlightLisp.highlight_drewc = HighlightLisp.highlight_element;
  
  HighlightLisp.highlight_element = function(code_el)
   {  
    this.highlight_drewc(code_el);
    var html = code_el.innerHTML;
    html = html.replace(/<(?!\/span>|span(.*)>)/g, '&lt;');
    // html = html.replace(/(?!span)>/g, '&amp;');
    /* html = html.replace(/(?!<span)>/g, '&gt;'); */
   //     console.log(html);
    code_el.innerHTML = html;
   };

function isElementVisible(elementToBeChecked)
{
    var TopView = $(window).scrollTop();
    var BotView = TopView + $(window).height();
    var TopElement = $(elementToBeChecked).offset().top;
    var BotElement = TopElement + $(elementToBeChecked).height();
    return ((BotElement <= BotView) && (TopElement >= TopView));
}

function make_it_so(thing)
{
  var li_for_nav = thing.target;
  var nav = thing.currentTarget;

  if (!isElementVisible(li_for_nav)) 
  {
   /* var href=$( li_for_nav ).find('a')[0].hash;
   var section = $(href)[0];

   var link_top = $( li_for_nav ).offset().top;
   var section_top = $( section ).offset().top;
   var nav_top = $( nav ).offset().top 

   var new_nav_top = (nav_top + $(window).height()) - section_top;
   
   $( nav ).css('position', 'fixed');
   $( nav ).css('top', '50px'); */
   
     


  
  } else { 
  console.log('active')
  }
}

$('#affix-nav').on('activate.bs.scrollspy', function (event) {
 // console.log(event);  
 make_it_so(event);

})



</script><script>HighlightLisp.highlight_auto();</script></body></html>