<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Org Syntax (draft)</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="title" content="Org Syntax (draft)"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-03-08T13:58-0800"/>
<meta name="author" content="Nicolas Goaziou"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Org Syntax (draft)</h1>

<p>This document describes and comments Org syntax as it is currently
read by its parser (Org Elements) and, therefore, by the export
framework.  It also includes a few comments on that syntax.
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Syntax</a></li>
<li><a href="#Headlines_and_Sections">2 Headlines and Sections</a>
<ul>
<li><a href="#sec-2-1">2.1 Headline</a>
<ul>
<li><a href="#sec-2-1-1">2.1.1 STARS</a></li>
<li><a href="#sec-2-1-2">2.1.2 KEYWORDS</a></li>
<li><a href="#sec-2-1-3">2.1.3 PRIORITY</a></li>
<li><a href="#sec-2-1-4">2.1.4 TITLE</a></li>
<li><a href="#sec-2-1-5">2.1.5 TAGS</a></li>
<li><a href="#sec-2-1-6">2.1.6 Valid Headlines</a></li>
<li><a href="#sec-2-1-7">2.1.7 comments and quotes</a></li>
<li><a href="#sec-2-1-8">2.1.8 footnote-section</a></li>
<li><a href="#sec-2-1-9">2.1.9 archive-tag</a></li>
<li><a href="#sec-2-1-10">2.1.10 The headline file</a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2 Sections</a></li>
</ul>
</li>
<li><a href="#Affiliated_keywords">3 Affiliated Keywords</a></li>
<li><a href="#Greater_Elements">4 Greater Elements</a>
<ul>
<li><a href="#Greater_Blocks">4.1 Greater Blocks</a></li>
<li><a href="#Drawers_and_Property_Drawers">4.2 Drawers and Property Drawers</a></li>
<li><a href="#Dynamic_Blocks">4.3 Dynamic Blocks</a></li>
<li><a href="#Footnote_Definitions">4.4 Footnote Definitions</a></li>
<li><a href="#Inlinetasks">4.5 Inlinetasks</a></li>
<li><a href="#Plain_Lists_and_Items">4.6 Plain Lists and Items</a></li>
<li><a href="#Tables">4.7 Tables</a></li>
</ul>
</li>
<li><a href="#Elements">5 Elements</a>
<ul>
<li><a href="#Babel_Call">5.1 Babel Call</a></li>
<li><a href="#Blocks">5.2 Blocks</a></li>
<li><a href="#Clock-_Diary_Sexp_and_Planning">5.3 Clock, Diary Sexp and Planning</a></li>
<li><a href="#Comments">5.4 Comments</a></li>
<li><a href="#Fixed_Width_Areas">5.5 Fixed Width Areas</a></li>
<li><a href="#Horizontal_Rules">5.6 Horizontal Rules</a></li>
<li><a href="#Keywords">5.7 Keywords</a></li>
<li><a href="#LaTeX_Environments">5.8 LaTeX Environments</a></li>
<li><a href="#Node_Properties">5.9 Node Properties</a></li>
<li><a href="#Paragraphs">5.10 Paragraphs</a></li>
<li><a href="#Table_Rows">5.11 Table Rows</a></li>
</ul>
</li>
<li><a href="#Objects">6 Objects</a>
<ul>
<li><a href="#Entities_and_LaTeX_Fragments">6.1 Entities and LaTeX Fragments</a></li>
<li><a href="#Export_Snippets">6.2 Export Snippets</a></li>
<li><a href="#Footnote_References">6.3 Footnote References</a></li>
<li><a href="#Inline_Babel_Calls_and_Source_Blocks">6.4 Inline Babel Calls and Source Blocks</a></li>
<li><a href="#Line_Breaks">6.5 Line Breaks</a></li>
<li><a href="#Links">6.6 Links</a></li>
<li><a href="#Macros">6.7 Macros</a></li>
<li><a href="#Targets_and_Radio_Targets">6.8 Targets and Radio Targets</a></li>
<li><a href="#Statistics_Cookies">6.9 Statistics Cookies</a></li>
<li><a href="#Subscript_and_Superscript">6.10 Subscript and Superscript</a></li>
<li><a href="#Table_Cells">6.11 Table Cells</a></li>
<li><a href="#Timestamp">6.12 Timestamps</a></li>
<li><a href="#Emphasis_Markers">6.13 Text Markup</a></li>
</ul>
</li>
<li><a href="#sec-7">7 Appendix</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Syntax</h2>
<div class="outline-text-2" id="text-1">




<pre class="example">(defclass syntax () ())

(defmethod print-object ((object syntax) stream)
  (print-unreadable-object (object stream :type t :identity nil)
    (let ((class (class-of object)))
      (dolist (slotd (c2mop:class-slots class))
        (format stream "~%    ~S: ~S" (c2mop:slot-definition-name slotd)
                (handler-case (c2mop:slot-value-using-class class object slotd)
                  (unbound-slot () '|#&lt;unbound&gt;| )))))))    
</pre>


<p>
A core concept in this syntax is that only headlines and sections are
context-free<sup><a class="footref" name="fnr-Headlines_and_Sections.1" href="#fn-Headlines_and_Sections.1">1</a></sup><sup>, </sup><sup><a class="footref" name="fnr-Headlines_and_Sections.2" href="#fn-Headlines_and_Sections.2">2</a></sup>.  Every other syntactical part only exists
within specific environments.
</p>
<p>
Three categories are used to classify these environments: "Greater
elements", "elements", and "objects", from the broadest scope to the
narrowest.  The word "element" is used for both Greater and non-Greater
elements, the context should make that clear.
</p>
<p>
The paragraph is the unit of measurement.  An element defines
syntactical parts that are at the same level as a paragraph,
i.e. which cannot contain or be included in a paragraph.  An object is
a part that could be included in an element.  Greater elements are all
parts that can contain an element.
</p>



<pre class="example">(defvar *whitespace* '(#\Space #\Tab)) 

(defun .whitespace ()
  (.is 'member *whitespace*))

(defclass whitespace (syntax)
  ((whitespace-prefix :initarg :whitespace-prefix
        :accessor whitespace-prefix)
   (whitespace-postfix :initarg :whitespace-postfix
         :accessor whitespace-postfix)))
</pre>



<pre class="example">(defun .string-of (parser &amp;key (using '.some))
  (coerce (funcall using parser) 'cl:string))  
</pre>



<pre class="example">(defun .line (&amp;optional (nl #\Newline))
  (.prog1 (.coerce (.some (.is-not #'char= nl)) 
                   'cl:string)
          (.is #'char= nl)))
</pre>



<pre class="example">(defstruct until 
  contents end)

(defun .until (parser &amp;key (do (.item)) contents)
  (.let* ((until (.or parser (.result nil))))
    (if until 
        (.result (make-until :contents (reverse contents)
                             :end until))
        (.let* ((first do))
          (.until parser :do do :contents (list* first contents))))))

</pre>


<p>
Empty lines belong to the largest element ending before them.  For
example, in a list, empty lines between items belong are part of the
item before them, but empty lines at the end of a list belong to the
plain list element.
</p>
<p>
Unless specified otherwise, case is not significant.
</p>
</div>

</div>

<div id="outline-container-Headlines_and_Sections" class="outline-2">
<h2 id="Headlines_and_Sections"><a name="sec-2" id="sec-2"></a><span class="section-number-2">2</span> Headlines and Sections</h2>
<div class="outline-text-2" id="text-Headlines_and_Sections">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Headline</h3>
<div class="outline-text-3" id="text-2-1">

<p>  A headline is defined as:
</p>



<pre class="example">STARS KEYWORD PRIORITY TITLE TAGS
</pre>


<p>
  (defun .headline ()
    (.let* ((stars <a name="STARS" class="target">STARS</a> )
            (keyword (.optional 
                      <a name="KEYWORD" class="target">KEYWORD</a> ))
            (priority (.optional 
                       <a name="PRIORITY" class="target">PRIORITY</a> ))
            (title (.optional 
                    <a name="TITLE" class="target">TITLE</a> ))
            (tags (.optional 
                   <a name="TAGS" class="target">TAGS</a> )))
      (.prog1 
       (.result (make-headline 
                 :start stars
                 :keyword keyword 
                 :priority priority
                 :title title
                 :tags tags))
       (.some (.is 'char= #\Space))
       (.or  (.not (.item))
             (.is 'char= #\Newline)))))
</p>



<pre class="example">(defstruct headline 
  stars keyword priority title tags)
</pre>



</div>

<div id="outline-container-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> STARS</h4>
<div class="outline-text-4" id="text-2-1-1">


<p>
    STARS is a string starting at column 0, containing at least one
    asterisk (and up to <code>org-inlinetask-min-level</code> if <code>org-inlinetask</code>
    library is loaded) and ended by a space character.  The number of
    asterisks is used to define the level of the headline.  It's the
    sole compulsory part of a headline.
</p>



<pre class="example">(defun .headline/stars ()
  "=&gt; /HEADLINE/ : a [headline]"
  (.make 
   'make-headline
   :stars (.prog1 
           (.every (.is 'char= #\*))
           (.is 'char= #\Space))))
</pre>


</div>

</div>

<div id="outline-container-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> KEYWORDS</h4>
<div class="outline-text-4" id="text-2-1-2">


<blockquote>

<p>KEYWORD is a TODO keyword, which has to belong to the list defined in
<code>org-todo-keywords-1</code>.  Case is significant.
</p>
</blockquote>






<pre class="example">(defun .keyword () 
  (.prog1 
   (apply #'.or (mapcar #'.string= (org-parameter 'org-todo-keywords-1)))
   (.is #'char= #\Space)))
</pre>





<pre class="example">(define-org-parameter 
  org-todo-keywords-1 
 '("TODO"
   "STARTED"
   "DONE")
 "The Org TODO Keywords")
</pre>



</div>

</div>

<div id="outline-container-2-1-3" class="outline-4">
<h4 id="sec-2-1-3"><span class="section-number-4">2.1.3</span> PRIORITY</h4>
<div class="outline-text-4" id="text-2-1-3">

<p>   PRIORITY is a priority cookie, i.e. a single letter preceded by
   a hash sign # and enclosed within square brackets.
</p>



<pre class="example">(.prog2
  (.string= "[#")
  (.is 'alpha-char-p)
  (.string= "] "))
</pre>


</div>

</div>

<div id="outline-container-2-1-4" class="outline-4">
<h4 id="sec-2-1-4"><span class="section-number-4">2.1.4</span> TITLE</h4>
<div class="outline-text-4" id="text-2-1-4">

<p>   TITLE can be made of any character but a new line.  Though, it will
   match after every other part have been matched.
</p>



<pre class="example">(.coerce (.every 
 (.progn (.not (.tags)) 
         (.is-not 'char= #\Newline)))
 'cl:string)
</pre>


</div>

</div>

<div id="outline-container-2-1-5" class="outline-4">
<h4 id="sec-2-1-5"><span class="section-number-4">2.1.5</span> TAGS</h4>
<div class="outline-text-4" id="text-2-1-5">

<p>   TAGS is made of words containing any alpha-numeric character,
   underscore, at sign, hash sign or percent sign, and separated with
   colons.
</p>



<pre class="example">(flet ((.tag () (.progn (.is 'char= #\:)
                        (.coerce 
                         (.every 
                          (.or (.is 'alphanumericp)
                               (.is 'member '(#\_ #\@ #\# #\%))))
                          'cl:string))))
  (.let* ((tags (.every (.tag))))
    (.progn (.is 'char= #\:)
            (.result tags))))
</pre>


</div>

</div>

<div id="outline-container-2-1-6" class="outline-4">
<h4 id="sec-2-1-6"><span class="section-number-4">2.1.6</span> Valid Headlines</h4>
<div class="outline-text-4" id="text-2-1-6">

<p>   Examples of valid headlines include:
</p>



<pre class="example">* 

** DONE

*** Some e-mail

**** TODO [#A] COMMENT Title :tag:a2%: 
</pre>


</div>

</div>

<div id="outline-container-2-1-7" class="outline-4">
<h4 id="sec-2-1-7"><span class="section-number-4">2.1.7</span> comments and quotes</h4>
<div class="outline-text-4" id="text-2-1-7">


<p>     
   If the first word appearing in the title is <code>org-comment-string</code>,
   the headline will be considered as "commented".  If that first word
   is <code>org-quote-string</code>, it will be considered as "quoted".  In both
   situations, case is significant.
</p>



<pre class="example">(make-org-parameter 
 'org-comment-string
 "COMMENT"
 "If the first word appearing in the title is ~org-comment-string~, 
the headline will be considered as \"commented\"")

</pre>



<pre class="example">(make-org-parameter 
 'org-quote-string 
 "QUOTE"
 "If that first word is ~org-quote-string~, it will be considered as
 \"quoted\"")
</pre>



<pre class="example">(flet ((%P (param headline)
         (.run (.string= (org-parameter param)) 
               (headline-title headline))))

  (defun headline-commented-p (headline) 
    (%P 'org-comment-string headline))

  (defun headline-quoted-p (headline) 
    (%P 'org-quote-string headline)))
</pre>


</div>

</div>

<div id="outline-container-2-1-8" class="outline-4">
<h4 id="sec-2-1-8"><span class="section-number-4">2.1.8</span> footnote-section</h4>
<div class="outline-text-4" id="text-2-1-8">

<p>   If its title is <code>org-footnote-section</code>, it will be considered as
   a "footnote section".  Case is significant.
</p>



<pre class="example">  (make-org-parameter 
   'org-footnote-section 
   "Footnotes"
   "If its title is ~org-footnote-section~, it will be considered as
a \"footnote section\"")
</pre>


</div>

</div>

<div id="outline-container-2-1-9" class="outline-4">
<h4 id="sec-2-1-9"><span class="section-number-4">2.1.9</span> archive-tag</h4>
<div class="outline-text-4" id="text-2-1-9">

<p>   If <code>org-archive-tag</code> is one of its tags, it will be considered as
   "archived".  Case is significant.
</p>



<pre class="example">  (make-org-parameter 
   'org-archive-tag 
   "ARCHIVE"
   "If ~org-archive-tag~ is one of its tags, it will be considered as
\"archived\"")
</pre>



</div>

</div>

<div id="outline-container-2-1-10" class="outline-4">
<h4 id="sec-2-1-10"><span class="section-number-4">2.1.10</span> The headline file</h4>
<div class="outline-text-4" id="text-2-1-10">





<pre class="example">(defpackage :smug/parser/org/headline
  (:use :cl 
        :smug/parser/org/dot
        :smug/parser/org/util
        :smug/parser/org/parameters)
  (:export #:.headline))
(in-package :smug/parser/org/headline)

&lt;&lt;headline&gt;&gt;

&lt;&lt;.headline/stars&gt;&gt;
&lt;&lt;headline-keywords-comment&gt;&gt;
&lt;&lt;parameters-org-todo-keywords-1&gt;&gt;

</pre>

</div>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Sections</h3>
<div class="outline-text-3" id="text-2-2">


<p>
  A headline contains directly one section (optionally), followed by
  any number of deeper level headlines.
</p>
<p>
  A section contains directly any greater element or element.  Only
  a headline can contain a section.  As an exception, text before the
  first headline in the document also belongs to a section.
</p>
<p>
  If a quoted headline contains a section, the latter will be
  considered as a "quote section".
</p>


<p>
  As an example, consider the following document:
</p>



<pre class="example">An introduction.

* A Headline 

  Some text.

** Sub-Topic 1

** Sub-Topic 2

*** Additional entry 

** QUOTE Another Sub-Topic

   Some other text.
</pre>




  Its internal structure could be summarized as:


<pre class="example">(document
 (section)
 (headline
  (section)
  (headline)
  (headline
   (headline))
  (headline
   (quote-section))))
</pre>


</div>
</div>

</div>

<div id="outline-container-Affiliated_keywords" class="outline-2">
<h2 id="Affiliated_keywords"><a name="sec-3" id="sec-3"></a><span class="section-number-2">3</span> Affiliated Keywords</h2>
<div class="outline-text-2" id="text-Affiliated_keywords">


<p>
  With the exception of <a href="#Inlinetasks">inlinetasks</a>, <a href="#Plain_Lists_and_Items">items</a>, <a href="#Clock-_Diary_Sexp_and_Planning">planning</a>, <a href="#Clock-_Diary_Sexp_and_Planning">clocks</a>, <a href="#Node_Properties">node properties</a> and <a href="#Table_Rows">table rows</a>, every other element type can be assigned
  attributes.
</p>
<p>
  This is done by adding specific keywords, named "affiliated
  keywords", just above the element considered, no blank line
  allowed.
</p>



<pre class="example">(defclass |keyword| (whitespace)
  ((name :initarg :name
         :accessor keyword-name)
   (value :initarg :value
          :accessor keyword-value)))

(defun .keyword ()
  (.make-instance 
   '|keyword|
   :whitespace-prefix (.some (.whitespace))
   :name (.coerce 
          (.progn          
           (.string= "#+")
           (.every (.is-not 'member '(#\Newline #\:))))
          'cl:string)
   :value (.progn 
           (.string= ": ")
           (.line))))

(defun |keywordp| (thing)
  (typep thing '|keyword|))

</pre>


<p>  
  Affiliated keywords are built upon one of the following patterns:
  "#+KEY: VALUE", "#+KEY[OPTIONAL]: VALUE" or "#+ATTR<sub>BACKEND</sub>: VALUE".
</p>
<p>
  KEY is either "CAPTION", "HEADER", "NAME", "PLOT" or "RESULTS"
  string.
</p>



<pre class="example">(.is 'member '("CAPTION" "HEADER" "NAME" "PLOT" "RESULTS")
     :test 'string-equal)

</pre>


<p>  
  BACKEND is a string constituted of alpha-numeric characters, hyphens
  or underscores.
</p>
<p>
  OPTIONAL and VALUE can contain any character but a new line.  Only
  "CAPTION" and "RESULTS" keywords can have an optional value.
</p>
<p>
  An affiliated keyword can appear more than once if KEY is either
  "CAPTION" or "HEADER" or if its pattern is "#+ATTR<sub>BACKEND</sub>: VALUE".
</p>
<p>
  "CAPTION", "AUTHOR", "DATE" and "TITLE" keywords can contain objects
  in their value and their optional value, if applicable.
</p>
</div>

</div>

<div id="outline-container-Greater_Elements" class="outline-2">
<h2 id="Greater_Elements"><a name="sec-4" id="sec-4"></a><a name="ID-5762b879-10fc-47ac-b8a9-59007996d49b" id="ID-5762b879-10fc-47ac-b8a9-59007996d49b"></a><span class="section-number-2">4</span> Greater Elements</h2>
<div class="outline-text-2" id="text-Greater_Elements">


<p>  
  Unless specified otherwise, greater elements can contain directly
  any other element or greater element excepted:
</p>
<ul>
<li>elements of their own type,
</li>
<li><a href="#Node_Properties">node properties</a>, which can only be found in <a href="#Drawers_and_Property_Drawers">property drawers</a>,
</li>
<li><a href="#Plain_Lists_and_Items">items</a>, which can only be found in <a href="#Plain_Lists_and_Items">plain lists</a>.
</li>
</ul>





<pre class="example">(defclass greater-element (whitespace)
  ((keywords :initarg :keywords 
             :accessor greater-element-keywords)))

(defun .greater-element (.parser)
  (.let* ((keys (.some (.keyword)))
          (pre (.some (.whitespace)))
          (element .parser))
    (setf (greater-element-keywords element) keys
          (whitespace-prefix element) pre)
    (.result element)))              
</pre>



</div>

<div id="outline-container-Greater_Blocks" class="outline-3">
<h3 id="Greater_Blocks"><a name="sec-4-1" id="sec-4-1"></a><a name="ID-14d26d49-9e9b-42db-a9c9-d8e722bb3234" id="ID-14d26d49-9e9b-42db-a9c9-d8e722bb3234"></a><span class="section-number-3">4.1</span> Greater Blocks</h3>
<div class="outline-text-3" id="text-Greater_Blocks">


<p>
   Greater blocks consist in the following pattern:
</p>



<pre class="example">#+BEGIN_NAME PARAMETERS
CONTENTS
#+END_NAME
</pre>



<pre class="example">(defclass greater-block (greater-element)
  ((name :initarg :name
         :accessor greater-block-name)
   (parameters :initarg :parameters
         :accessor greater-block-parameters)
   (contents :initarg :contents
         :accessor greater-block-contents)))

</pre>


<p>
   NAME can contain any non-whitespace character.
</p>



<pre class="example">(.every (.is-not 'member (cons #\Newline *whitespace*)))
</pre>


<p>
   PARAMETERS can contain any character other than new line, and can
   be omitted.
</p>



<pre class="example">(.progn (.whitespace) (.line))
</pre>


<p>
   If NAME is "CENTER", it will be a "center block".  If it is
   "QUOTE", it will be a "quote block".
</p>



<pre class="example">(defclass center-block (greater-block) ())

(add-greater-block "CENTER" 'center-block)

(defclass quote-block (greater-block) ())) 

(add-greater-block "QUOTE" 'quote-block)
</pre>



<pre class="example">(defun .greater-block ()
  (flet ((.end-block (name)
           (.progn (.some (.whitespace))
                   (.string-equal 
                    (concatenate 'string
                                 "#+END_" name)))))

    (.let* ((keywords (.some (.keyword)))
            (_ (.string-equal "#+BEGIN_"))
            (name 
             (.coerce 
              &lt;&lt;greater-block-name&gt;&gt;
              'cl:string))
            (parameters
             &lt;&lt;greater-block-parameters&gt;&gt;)
            (contents (.until (.end-block name) 
                              :do (.line))))
      (.result (make-greater-block-instance 
                name
                :keywords keywords
                :name name
                :parameters parameters
                :contents (until-contents 
                           contents))))))

</pre>



<pre class="example">(defvar *greater-block-classes* (list))

(defun greater-block-classes ()
  *greater-block-classes*)

(defun (setf greater-block-classes) (value)
  (setf *greater-block-classes* value))

(defun add-greater-block (name class)
  (push  (cons name class)
         (greater-block-classes)))

(defun make-greater-block-instance (name &amp;rest initargs)
  (apply #'make-instance 
    (destructuring-bind (_ . maker)
        (or (assoc name (greater-block-classes) 
                   :test #'string-equal)
            (assoc nil (greater-block-classes)))
      (declare (ignore _))
      maker)            
    initargs))




</pre>


<p>
   If the block is neither a center block, a quote block or a <a href="#Blocks">block element</a>, it will be a "special block".
</p>



<pre class="example">(defclass special-block (greater-block) ())
(add-greater-block nil 'special-block)  
</pre>


<p>      
   <a href="#CONTENTS">CONTENTS</a> can contain any element, except : a line <code>#+END_NAME</code> on
   its own.  Also lines beginning with STARS must be quoted by
   a comma.
</p>
</div>

</div>

<div id="outline-container-Drawers_and_Property_Drawers" class="outline-3">
<h3 id="Drawers_and_Property_Drawers"><a name="sec-4-2" id="sec-4-2"></a><span class="section-number-3">4.2</span> Drawers and Property Drawers</h3>
<div class="outline-text-3" id="text-Drawers_and_Property_Drawers">


<p>
   Pattern for drawers is:
</p>



<pre class="example">:NAME:
CONTENTS
:END:
</pre>


<p>
   NAME has to either be "PROPERTIES" or belong to <code>org-drawers</code> list.
</p>
<p>
   If NAME is "PROPERTIES", the drawer will become a "property
   drawer".
</p>
<p>
   In a property drawers, <a href="#CONTENTS">CONTENTS</a> can only contain <a href="#Node_Properties">node property</a>
   elements.  Otherwise it can contain any element but another drawer
   or property drawer.
</p>

<hr/>

<p>
   It would be nice if users hadn't to register drawers names before
   using them in <code>org-drawers</code> (or through the <code>#+DRAWERS:</code> keyword).
   Anything starting with <code>^[ \t]*:\w+:[ \t]$</code> and ending with
   <code>^[ \t]*:END:[ \t]$</code> could be considered as a drawer.  &mdash; ngz
</p>
</div>

</div>

<div id="outline-container-Dynamic_Blocks" class="outline-3">
<h3 id="Dynamic_Blocks"><a name="sec-4-3" id="sec-4-3"></a><span class="section-number-3">4.3</span> Dynamic Blocks</h3>
<div class="outline-text-3" id="text-Dynamic_Blocks">


<p>
   Pattern for dynamic blocks is:
</p>



<pre class="example">#+BEGIN: NAME PARAMETERS
CONTENTS
#+END:
</pre>


<p>
   NAME cannot contain any whitespace character.
</p>
<p>
   PARAMETERS can contain any character and can be omitted.
</p>
</div>

</div>

<div id="outline-container-Footnote_Definitions" class="outline-3">
<h3 id="Footnote_Definitions"><a name="sec-4-4" id="sec-4-4"></a><span class="section-number-3">4.4</span> Footnote Definitions</h3>
<div class="outline-text-3" id="text-Footnote_Definitions">


<p>
   Pattern for footnote definitions is:
</p>



<pre class="example">[LABEL] CONTENTS
</pre>


<p>
   It must start at column 0.
</p>
<p>
   LABEL is either a number or follows the pattern "fn:WORD", where
   word can contain any word-constituent character, hyphens and
   underscore characters.
</p>
<p>
   <a href="#CONTENTS">CONTENTS</a> can contain any element excepted another footnote
   definition.  It ends at the next footnote definition, the next
   headline, two consecutive empty lines or the end of buffer.
</p>
</div>

</div>

<div id="outline-container-Inlinetasks" class="outline-3">
<h3 id="Inlinetasks"><a name="sec-4-5" id="sec-4-5"></a><span class="section-number-3">4.5</span> Inlinetasks</h3>
<div class="outline-text-3" id="text-Inlinetasks">


<p>
   Inlinetasks are defined by <code>org-inlinetask-min-level</code> contiguous
   asterisk characters starting at column 0, followed by a whitespace
   character.
</p>
<p>
   Optionally, inlinetasks can be ended with a string constituted of
   <code>org-inlinetask-min-level</code> contiguous asterisk characters starting
   at column 0, followed by a space and the "END" string.
</p>
<p>
   Inlinetasks are recognized only after <code>org-inlinetask</code> library is
   loaded.
</p>
</div>

</div>

<div id="outline-container-Plain_Lists_and_Items" class="outline-3">
<h3 id="Plain_Lists_and_Items"><a name="sec-4-6" id="sec-4-6"></a><span class="section-number-3">4.6</span> Plain Lists and Items</h3>
<div class="outline-text-3" id="text-Plain_Lists_and_Items">


<p>
   Items are defined by a line starting with the following pattern:
   "BULLET COUNTER-SET CHECK-BOX TAG", in which only BULLET is
   mandatory.
</p>
<p>
   BULLET is either an asterisk, a hyphen, a plus sign character or
   follows either the pattern "COUNTER." or "COUNTER)".  In any case,
   BULLET is follwed by a whitespace character or line ending.
</p>
<p>
   COUNTER can be a number or a single letter.
</p>
<p>
   COUNTER-SET follows the pattern [@COUNTER].
</p>
<p>
   CHECK-BOX is either a single whitespace character, a "X" character
   or a hyphen, enclosed within square brackets.
</p>
<p>
   TAG follows "TAG-TEXT ::" pattern, where TAG-TEXT can contain any
   character but a new line.
</p>
<p>
   An item ends before the next item, the first line less or equally
   indented than its starting line, or two consecutive empty lines.
   Indentation of lines within other greater elements do not count,
   neither do inlinetasks boundaries.
</p>
<p>
   A plain list is a set of consecutive items of the same indentation.
   It can only directly contain items.
</p>
<p>
   If first item in a plain list has a counter in its bullet, the
   plain list will be an "ordered plain-list".  If it contains a tag,
   it will be a "descriptive list".  Otherwise, it will be an
   "unordered list".  List types are mutually exclusive.
</p>
<p>
   For example, consider the following excerpt of an Org document:
</p>



<pre class="example">1. item 1
2. [X] item 2
   - some tag :: item 2.1
</pre>


<p>
   Its internal structure is as follows:
</p>



<pre class="example">(ordered-plain-list
 (item)
 (item
  (descriptive-plain-list
   (item))))
</pre>


</div>

</div>

<div id="outline-container-Tables" class="outline-3">
<h3 id="Tables"><a name="sec-4-7" id="sec-4-7"></a><span class="section-number-3">4.7</span> Tables</h3>
<div class="outline-text-3" id="text-Tables">


<p>
   Tables start at lines beginning with either a vertical bar or the
   "+-" string followed by plus or minus signs only, assuming they are
   not preceded with lines of the same type.  These lines can be
   indented.
</p>
<p>
   A table starting with a vertical bar has "org" type.  Otherwise it
   has "table.el" type.
</p>
<p>
   Org tables end at the first line not starting with a vertical bar.
   Table.el tables end at the first line not starting with either
   a vertical line or a plus sign.  Such lines can be indented.
</p>
<p>
   An org table can only contain table rows.  A table.el table does
   not contain anything.
</p>
<p>
   One or more "#+TBLFM: FORMULAS" lines, where "FORMULAS" can contain
   any character, can follow an org table.
</p>
</div>
</div>

</div>

<div id="outline-container-Elements" class="outline-2">
<h2 id="Elements"><a name="sec-5" id="sec-5"></a><span class="section-number-2">5</span> Elements</h2>
<div class="outline-text-2" id="text-Elements">


<p>
  Elements cannot contain any other element.
</p>
<p>
  Only <a href="#Keywords">keywords</a> whose name belongs to
  <code>org-element-document-properties</code>, <a href="#Blocks">verse blocks</a> , <a href="#Paragraphs">paragraphs</a> and
  <a href="#Table_Rows">table rows</a> can contain objects.
</p>

</div>

<div id="outline-container-Babel_Call" class="outline-3">
<h3 id="Babel_Call"><a name="sec-5-1" id="sec-5-1"></a><span class="section-number-3">5.1</span> Babel Call</h3>
<div class="outline-text-3" id="text-Babel_Call">


<p>
   Pattern for babel calls is:
</p>



<pre class="example">#+CALL: VALUE
</pre>


<p>
   VALUE is optional.  It can contain any character but a new line.
</p>
</div>

</div>

<div id="outline-container-Blocks" class="outline-3">
<h3 id="Blocks"><a name="sec-5-2" id="sec-5-2"></a><a name="ID-618477d5-cb28-4eff-a5ef-cc9b54dc8fb7" id="ID-618477d5-cb28-4eff-a5ef-cc9b54dc8fb7"></a><span class="section-number-3">5.2</span> Blocks</h3>
<div class="outline-text-3" id="text-Blocks">


<p>
   Like <a href="#Greater_Blocks">greater blocks</a>, pattern for blocks is:
</p>



<pre class="example">#+BEGIN_NAME DATA
CONTENTS
#+END_NAME
</pre>



<pre class="example">(defclass element-block (greater-block) 
 ((name :accessor element-block-name)
  (parameters :initarg :parameters
              :accessor element-block-data)
  (contents :initarg :contents
            :accessor element-block-contents)))

</pre>


<p>
   NAME cannot contain any whitespace character.
</p>
<p>   
   If NAME is "COMMENT", it will be a "comment block".  If it is
   "EXAMPLE", it will be an "example block".  If it is "SRC", it will
   be a "source block".  If it is "VERSE", it will be a "verse block".
</p>



<pre class="example">(defclass comment-block (element-block) ())
(add-greater-block "COMMENT" 'comment-block)

(defclass example-block (element-block) ())
(add-greater-block "EXAMPLE" 'example-block)

(defclass verse-block (element-block) ())
(add-greater-block "VERSE" 'verse-block)  

(defclass source-block (element-block) 
  &lt;&lt;source-block-slots&gt;&gt;)     
(add-greater-block "SRC" 'source-block)
</pre>


<p>
   If NAME is a string matching the name of any export back-end
   loaded, the block will be an "export block".
</p>
<p>
   DATA can contain any character but a new line.  It can be ommitted,
   unless the block is a "source block".  In this case, it must follow
   the pattern "LANGUAGE SWITCHES ARGUMENTS", where SWITCHES and
   ARGUMENTS are optional.
</p>



<pre class="example">((language :initarg :language 
          :accessor source-block-language)
 (switches :initarg :switches 
           :accessor source-block-switches)
 (arguments :initarg :arguments 
            :accessor source-block-arguments))    
</pre>


<p>
   LANGUAGE cannot contain any whitespace character
.
</p>


<pre class="example">(.every (.is-not 'member (cons #\Newline *whitespace*))) 
</pre>


<p>
   SWITCHES is made of any number of "SWITCH" patterns, separated by
   blank lines.
</p>
<p>
   A SWITCH pattern is either "-l "FORMAT"", where FORMAT can contain
   any character but a double quote and a new line, "-S" or "+S",
   where S stands for a single letter.
</p>
<p>
   ARGUMENTS can contain any character but a new line.
</p>



<pre class="example">(.optional (.every (.is-not 'eql #\Newline)))
</pre>



<pre class="example">
(defmethod initialize-instance :after ((source-block source-block)
                                       &amp;rest initargs)
  (declare (ignore initargs))
  (flet ((.data ()
           (.let* ((language 
                    &lt;&lt;source-block-language&gt;&gt;)
                   (switches (.result nil))
                   (_ (.optional (.is 'eql #\Space)))
                   (arguments 
                    &lt;&lt;source-block-arguments&gt;&gt;))
             (with-accessors ((l source-block-language)
                              (s source-block-switches)
                              (a source-block-arguments)) 
                 source-block
               (.result (setf l (coerce language 'cl:string)
                              s switches
                              a (coerce arguments 'cl:string)))))))
    (.run (.data) (element-block-data source-block))))

</pre>


<p>   
   <a href="#CONTENTS">CONTENTS</a> can contain any character, including new lines.  Though it
   will only contain Org objects if the block is a verse block.
   Otherwise, <a href="#contents">contents</a> will not be parsed.
</p>
</div>

</div>

<div id="outline-container-Clock-_Diary_Sexp_and_Planning" class="outline-3">
<h3 id="Clock-_Diary_Sexp_and_Planning"><a name="sec-5-3" id="sec-5-3"></a><span class="section-number-3">5.3</span> Clock, Diary Sexp and Planning</h3>
<div class="outline-text-3" id="text-Clock-_Diary_Sexp_and_Planning">


<p>
   A clock follows the pattern:
</p>



<pre class="example">CLOCK: TIMESTAMP DURATION
</pre>


<p>
   Both TIMESTAMP and DURATION are optional.
</p>
<p>
   TIMESTAMP is a <a href="#Timestamp">timestamp</a> object.
</p>
<p>
   DURATION follows the pattern:
</p>



<pre class="example">=&gt; HH:MM
</pre>


<p>
   HH is a number containing any number of digits.  MM is a two digit
   numbers.
</p>
<p>
   A diary sexp is a line starting at column 0 with "%%(" string.  It
   can then contain any character besides a new line.
</p>
<p>
   A planning is a line filled with more at most three INFO parts,
   where each INFO part follows the pattern:
</p>



<pre class="example">KEYWORD: TIMESTAMP
</pre>


<p>
   KEYWORD is a string among <code>org-deadline-string</code>,
   <code>org-scheduled-string</code> and <code>org-closed-string</code>.  TIMESTAMP is is
   a <a href="#Timestamp">timestamp</a> object.
</p>
<p>
   Even though a planning element can exist anywhere in a section or
   a greater element, it will only affect the headline containing the
   section if it is put on the line following that headline.
</p>
</div>

</div>

<div id="outline-container-Comments" class="outline-3">
<h3 id="Comments"><a name="sec-5-4" id="sec-5-4"></a><span class="section-number-3">5.4</span> Comments</h3>
<div class="outline-text-3" id="text-Comments">


<p>
   A "comment line" starts with a hash signe and a whitespace
   character or an end of line.
</p>
<p>
   Comments can contain any number of consecutive comment lines.
</p>
</div>

</div>

<div id="outline-container-Fixed_Width_Areas" class="outline-3">
<h3 id="Fixed_Width_Areas"><a name="sec-5-5" id="sec-5-5"></a><span class="section-number-3">5.5</span> Fixed Width Areas</h3>
<div class="outline-text-3" id="text-Fixed_Width_Areas">


<p>
   A "fixed-width line" start with a colon character and a whitespace
   or an end of line.
</p>
<p>
   Fixed width areas can contain any number of consecutive fixed-width
   lines.
</p>
</div>

</div>

<div id="outline-container-Horizontal_Rules" class="outline-3">
<h3 id="Horizontal_Rules"><a name="sec-5-6" id="sec-5-6"></a><span class="section-number-3">5.6</span> Horizontal Rules</h3>
<div class="outline-text-3" id="text-Horizontal_Rules">


<p>
   A horizontal rule is a line made of at least 5 consecutive hyphens.
   It can be indented.
</p>
</div>

</div>

<div id="outline-container-Keywords" class="outline-3">
<h3 id="Keywords"><a name="sec-5-7" id="sec-5-7"></a><span class="section-number-3">5.7</span> Keywords</h3>
<div class="outline-text-3" id="text-Keywords">


<p>
   Keywords follow the syntax:
</p>



<pre class="example">#+KEY: VALUE
</pre>


<p>
   KEY can contain any non-whitespace character, but it cannot be
   equal to "CALL" or any affiliated keyword.
</p>
<p>
   VALUE can contain any character excepted a new line.
</p>
<p>
   If KEY belongs to <code>org-element-document-properties</code>, VALUE can
   contain objects.
</p>
</div>

</div>

<div id="outline-container-LaTeX_Environments" class="outline-3">
<h3 id="LaTeX_Environments"><a name="sec-5-8" id="sec-5-8"></a><span class="section-number-3">5.8</span> LaTeX Environments</h3>
<div class="outline-text-3" id="text-LaTeX_Environments">


<p>
   Pattern for LaTeX environments is:
</p>



<pre class="example">\begin{NAME}
CONTENTS
\end{NAME}
</pre>


<p>
   NAME is constituted of alpha-numeric characters and may end with an
   asterisk.
</p>
<p>
   <a href="#CONTENTS">CONTENTS</a> can contain anything but the "\end{NAME}" string.
</p>
</div>

</div>

<div id="outline-container-Node_Properties" class="outline-3">
<h3 id="Node_Properties"><a name="sec-5-9" id="sec-5-9"></a><span class="section-number-3">5.9</span> Node Properties</h3>
<div class="outline-text-3" id="text-Node_Properties">


<p>
   Patter for node properties is:
</p>



<pre class="example">:PROPERTY: VALUE
</pre>


<p>
   PROPERTY can contain any non-whitespace character.  VALUE can
   contain any character but a new line.
</p>
<p>
   Node properties can only exist in a <a href="#Drawers_and_Property_Drawers">property drawers</a>.
</p>
</div>

</div>

<div id="outline-container-Paragraphs" class="outline-3">
<h3 id="Paragraphs"><a name="sec-5-10" id="sec-5-10"></a><span class="section-number-3">5.10</span> Paragraphs</h3>
<div class="outline-text-3" id="text-Paragraphs">


<p>
   Paragraphs are the default element, which means that any
   unrecognized context is a paragraph.
</p>
<p>
   Empty lines and other elements end paragraphs.
</p>
<p>
   Paragraphs can contain every type of object.
</p>
</div>

</div>

<div id="outline-container-Table_Rows" class="outline-3">
<h3 id="Table_Rows"><a name="sec-5-11" id="sec-5-11"></a><span class="section-number-3">5.11</span> Table Rows</h3>
<div class="outline-text-3" id="text-Table_Rows">


<p>
   A table rows is either constituted of a vertical bar and any number
   of <a href="#Table_Cells">table cells</a> or a vertical bar followed by a hyphen.
</p>
<p>
   In the first case the table row has the "standard" type.  In the
   second case, it has the "rule" type.
</p>
<p>
   Table rows can only exist in <a href="#Tables">tables</a>.
</p>
</div>
</div>

</div>

<div id="outline-container-Objects" class="outline-2">
<h2 id="Objects"><a name="sec-6" id="sec-6"></a><span class="section-number-2">6</span> Objects</h2>
<div class="outline-text-2" id="text-Objects">


<p>
  Objects can only be found in the following locations:
</p>
<ul>
<li><a href="#Affiliated_keywords">affiliated keywords</a> defined in <code>org-element-parsed-keywords</code>,
</li>
<li><a href="#Keywords">document properties</a>,
</li>
<li><a href="#Headlines_and_Sections">headline</a> titles,
</li>
<li><a href="#Inlinetasks">inlinetask</a> titles,
</li>
<li><a href="#Plain_Lists_and_Items">item</a> tags,
</li>
<li><a href="#Paragraphs">paragraphs</a>,
</li>
<li><a href="#Table_Cells">table cells</a>,
</li>
<li><a href="#Table_Rows">table rows</a>, which can only contain table cell
    objects,
</li>
<li><a href="#Blocks">verse blocks</a>.
</li>
</ul>


<p>    
  Most objects cannot contain objects.  Those which can will be
  specified.
</p>

</div>

<div id="outline-container-Entities_and_LaTeX_Fragments" class="outline-3">
<h3 id="Entities_and_LaTeX_Fragments"><a name="sec-6-1" id="sec-6-1"></a><span class="section-number-3">6.1</span> Entities and LaTeX Fragments</h3>
<div class="outline-text-3" id="text-Entities_and_LaTeX_Fragments">


<p>
   An entity follows the pattern:
</p>



<pre class="example">\NAME POST
</pre>


<p>
   where NAME has a valid association in either <code>org-entities</code> or
   <code>org-entities-user</code>.
</p>
<p>
   POST is the end of line, "{}" string, or a non-alphabetical
   character.  It isn't separated from NAME by a whitespace character.
</p>
<p>
   A LaTeX fragment can follow multiple patterns:
</p>



<pre class="example">\NAME POST
\(CONTENTS\)
\[CONTENTS\]
$$CONTENTS$$
PRE$CHAR$POST
PRE$BORDER1 BODY BORDER2$
</pre>


<p>
   NAME contains alphabetical characters only and must not have an
   association in either <code>org-entities</code> or <code>org-entities-user</code>.
</p>
<p>
   POST is the same as for entities.
</p>
<p>
   <a href="#CONTENTS">CONTENTS</a> can contain any character but cannot contain "\)" in the
   second template or "\]" in the third one.
</p>
<p>
   PRE is either the beginning of line or a character different from
   <code>$</code>.
</p>
<p>
   CHAR is a non-whitespace character different from <code>.</code>, ~,~, <code>?</code>,
   <code>;</code>, ~'~ or a double quote.
</p>
<p>
   POST is any of <code>-</code>, <code>.</code>, ~,~, <code>?</code>, <code>;</code>, <code>:</code>, ~'~, a double quote,
   a whitespace character and the end of line.
</p>
<p>
   BORDER1 is a non-whitespace character different from <code>.</code>, <code>;</code>, <code>.</code>
   and <code>$</code>.
</p>
<p>
   BODY can contain any character excepted <code>$</code>, and may not span over
   more than 3 lines.
</p>
<p>
   BORDER2 is any non-whitespace character different from ~,~, <code>.</code> and
   <code>$</code>.
</p>

<hr/>

<blockquote>

<p>It would introduce incompatibilities with previous Org versions,
but support for <code>$...$</code> (and for symmetry, <code>$$...$$</code>) constructs
ought to be removed.
</p>
<p>
They are slow to parse, fragile, redundant and imply false
positives.  &mdash; ngz
</p>
</blockquote>


</div>

</div>

<div id="outline-container-Export_Snippets" class="outline-3">
<h3 id="Export_Snippets"><a name="sec-6-2" id="sec-6-2"></a><span class="section-number-3">6.2</span> Export Snippets</h3>
<div class="outline-text-3" id="text-Export_Snippets">


<p>
   Patter for export snippets is:
</p>



<pre class="example">@@NAME:VALUE@@
</pre>


<p>
   NAME can contain any alpha-numeric character and hyphens.
</p>
<p>
   VALUE can contain anything but "@@" string.
</p>
</div>

</div>

<div id="outline-container-Footnote_References" class="outline-3">
<h3 id="Footnote_References"><a name="sec-6-3" id="sec-6-3"></a><span class="section-number-3">6.3</span> Footnote References</h3>
<div class="outline-text-3" id="text-Footnote_References">


<p>
   There are four patterns for footnote references:
</p>



<pre class="example">[MARK]
[fn:LABEL]
[fn:LABEL:DEFINITION]
[fn::DEFINITION]
</pre>


<p>
   MARK is a number.
</p>
<p>
   LABEL can contain any word constituent character, hyphens and
   underscores.
</p>
<p>
   DEFINITION can contain any character.  Though opening and closing
   square brackets must be balanced in it.  It can contain any object
   encountered in a paragraph, even other footnote references.
</p>
<p>
   If the reference follows the third pattern, it is called an "inline
   footnote".  If it follows the fourth one, i.e. if LABEL is omitted,
   it is an "anonymous footnote".
</p>
</div>

</div>

<div id="outline-container-Inline_Babel_Calls_and_Source_Blocks" class="outline-3">
<h3 id="Inline_Babel_Calls_and_Source_Blocks"><a name="sec-6-4" id="sec-6-4"></a><span class="section-number-3">6.4</span> Inline Babel Calls and Source Blocks</h3>
<div class="outline-text-3" id="text-Inline_Babel_Calls_and_Source_Blocks">


<p>
   Inline Babel calls follow any of the following patterns:
</p>



<pre class="example">call_NAME(ARGUMENTS)
call_NAME[HEADER](ARGUMENTS)[HEADER]
</pre>


<p>
   NAME can contain any character besides <code>(</code>, <code>)</code> and "\n".
</p>
<p>
   HEADER can contain any character besides <code>]</code> and "\n".
</p>
<p>
   ARGUMENTS can contain any character besides <code>)</code> and "\n".
</p>
<p>
   Inline source blocks follow any of the following patterns:
</p>



<pre class="example">src_LANG{BODY}
src_LANG[OPTIONS]{BODY}
</pre>


<p>
   LANG can contain any non-whitespace character.
</p>
<p>
   OPTIONS and BODY can contain any character but "\n".
</p>
</div>

</div>

<div id="outline-container-Line_Breaks" class="outline-3">
<h3 id="Line_Breaks"><a name="sec-6-5" id="sec-6-5"></a><span class="section-number-3">6.5</span> Line Breaks</h3>
<div class="outline-text-3" id="text-Line_Breaks">


<p>
   A line break consists in "\\SPACE" pattern at the end of an
   otherwise non-empty line.
</p>
<p>
   SPACE can contain any number of tabs and spaces, including 0.
</p>
</div>

</div>

<div id="outline-container-Links" class="outline-3">
<h3 id="Links"><a name="sec-6-6" id="sec-6-6"></a><span class="section-number-3">6.6</span> Links</h3>
<div class="outline-text-3" id="text-Links">


<p>
   There are 4 major types of links:
</p>



<pre class="example">RADIO                     ("radio" link)
&lt;PROTOCOL:PATH&gt;           ("angle" link)
PRE PROTOCOL:PATH2 POST   ("plain" link)
[[PATH3]DESCRIPTION]      ("regular" link)
</pre>


<p>
   RADIO is a string matched by some <a href="#Targets_and_Radio_Targets">radio target</a>.  It can contain
   <a href="#Entities_and_LaTeX_Fragments">entities</a>, <a href="#Entities_and_LaTeX_Fragments">latex fragments</a>, <a href="#Subscript_and_Superscript">subscript</a> and <a href="#Subscript_and_Superscript">superscript</a> only.
</p>
<p>
   PROTOCOL is a string among <code>org-link-types</code>.
</p>
<p>
   PATH can contain any character but <code>]</code>, <code>&lt;</code>, <code>&gt;</code> and <code>\n</code>.
</p>
<p>
   PRE and POST are non word constituent.  They can be, respectively,
   the beginning or the end of a line.
</p>
<p>
   PATH2 can contain any non-whitespace character excepted <code>(</code>, <code>)</code>,
   <code>&lt;</code> and <code>&gt;</code>.  It must end with a word-constituent character, or any
   non-whitespace non-punctuation character followed by <code>/</code>.
</p>
<p>
   DESCRIPTION must be enclosed within square brackets.  It can
   contain any character but square brackets.  Object-wise, it can
   contain any object found in a paragraph excepted a <a href="#Footnote_References">footnote reference</a>, a <a href="#Targets_and_Radio_Targets">radio target</a> and a <a href="#Line_Breaks">line break</a>.  It cannot contain
   another link either, unless it is a plain link.
</p>
<p>
   DESCRIPTION is optional.
</p>
<p>
   PATH3 is built according to the following patterns:
</p>



<pre class="example">FILENAME           ("file" type)
PROTOCOL:PATH4     ("PROTOCOL" type)
id:ID              ("id" type)
#CUSTOM-ID         ("custom-id" type)
(CODEREF)          ("coderef" type)
FUZZY              ("fuzzy" type)
</pre>


<p>
   FILENAME is a file name, either absolute or relative.
</p>
<p>
   PATH4 can contain any character besides square brackets.
</p>
<p>
   ID is constituted of hexadecimal numbers separated with hyphens.
</p>
<p>
   PATH4, CUSTOM-ID, CODEREF and FUZZY can contain any character
   besides square brackets.
</p>

<hr/>

<blockquote>

<p>I suggest to remove angle links.  If one needs spaces in PATH, she
can use standard link syntax instead.
</p>
<p>
I also suggest to remove <code>org-link-types</code> dependency in PROTOCOL
and match <code>[a-zA-Z]</code> instead, for portability.  &mdash; ngz
</p>
</blockquote>


</div>

</div>

<div id="outline-container-Macros" class="outline-3">
<h3 id="Macros"><a name="sec-6-7" id="sec-6-7"></a><span class="section-number-3">6.7</span> Macros</h3>
<div class="outline-text-3" id="text-Macros">


<p>
   Macros follow the pattern:
</p>



<pre class="example">{{{NAME(ARGUMENTS)}}}
</pre>


<p>
   NAME must start with a letter and can be followed by any number of
   alpha-numeric characters, hyphens and underscores.
</p>
<p>
   ARGUMENTS can contain anything but "}}}" string.  Values within
   ARGUMENTS are separated by commas.  Non-separating commas have to
   be escaped with a backslash character.
</p>
</div>

</div>

<div id="outline-container-Targets_and_Radio_Targets" class="outline-3">
<h3 id="Targets_and_Radio_Targets"><a name="sec-6-8" id="sec-6-8"></a><span class="section-number-3">6.8</span> Targets and Radio Targets</h3>
<div class="outline-text-3" id="text-Targets_and_Radio_Targets">


<p>
   Radio targets follow the pattern:
</p>



<pre class="example">&lt;&lt;&lt;CONTENTS&gt;&gt;&gt;
</pre>


<p>
   <a href="#CONTENTS">CONTENTS</a> can be any character besides <code>&lt;</code>, <code>&gt;</code> and "\n".  As far as
   objects go, it can contain <a href="#Entities_and_LaTeX_Fragments">entities</a>, <a href="#Entities_and_LaTeX_Fragments">latex fragments</a>, <a href="#Subscript_and_Superscript">subscript</a> and
   <a href="#Subscript_and_Superscript">superscript</a> only.
</p>
<p>
   Targets follow the pattern:
</p>



<pre class="example">&lt;&lt;TARGET&gt;&gt;
</pre>


<p>
   TARGET can contain any character besides <code>&lt;</code>, <code>&gt;</code> and "\n".  It
   cannot contain any object.
</p>
</div>

</div>

<div id="outline-container-Statistics_Cookies" class="outline-3">
<h3 id="Statistics_Cookies"><a name="sec-6-9" id="sec-6-9"></a><span class="section-number-3">6.9</span> Statistics Cookies</h3>
<div class="outline-text-3" id="text-Statistics_Cookies">


<p>
   Statistics cookies follow either pattern:
</p>



<pre class="example">[PERCENT%]
[NUM1/NUM2]
</pre>


<p>
   PERCENT, NUM1 and NUM2 are numbers or the empty string.
</p>
</div>

</div>

<div id="outline-container-Subscript_and_Superscript" class="outline-3">
<h3 id="Subscript_and_Superscript"><a name="sec-6-10" id="sec-6-10"></a><span class="section-number-3">6.10</span> Subscript and Superscript</h3>
<div class="outline-text-3" id="text-Subscript_and_Superscript">


<p>
   Pattern for subscript is:
</p>



<pre class="example">CHAR_SCRIPT
</pre>


<p>
   Pattern for superscript is:
</p>



<pre class="example">CHAR^SCRIPT
</pre>


<p>
   CHAR is any non-whitespace character.
</p>
<p>
   SCRIPT can be <code>*</code>, a string made of word-constituent characters
   maybe preceded by a plus or a minus sign, an expression enclosed in
   parenthesis (resp. curly brackets) containing balanced parenthesis
   (resp. curly brackets).
</p>
</div>

</div>

<div id="outline-container-Table_Cells" class="outline-3">
<h3 id="Table_Cells"><a name="sec-6-11" id="sec-6-11"></a><span class="section-number-3">6.11</span> Table Cells</h3>
<div class="outline-text-3" id="text-Table_Cells">


<p>
   Table cells follow the pattern:
</p>



<pre class="example">CONTENTS|
</pre>


<p>
   <a href="#CONTENTS">CONTENTS</a> can contain any character excepted a vertical bar.
</p>
</div>

</div>

<div id="outline-container-Timestamp" class="outline-3">
<h3 id="Timestamp"><a name="sec-6-12" id="sec-6-12"></a><span class="section-number-3">6.12</span> Timestamps</h3>
<div class="outline-text-3" id="text-Timestamp">


<p>
   There are seven possible patterns for timestamps:
</p>



<pre class="example">&lt;%%(SEXP)&gt;                                     (diary)
&lt;DATE TIME REPEATER&gt;                         (active)
[DATE TIME REPEATER]                         (inactive)
&lt;DATE TIME REPEATER&gt;--&lt;DATE TIME REPEATER&gt;   (active range)
&lt;DATE TIME-TIME REPEATER&gt;                    (active range)
[DATE TIME REPEATER]--[DATE TIME REPEATER]   (inactive range)
[DATE TIME-TIME REPEATER]                    (inactive range)
</pre>


<p>
   SEXP can contain any character excepted <code>&gt;</code> and <code>\n</code>.
</p>
<p>
   DATE follows the pattern:
</p>



<pre class="example">YYYY-MM-DD DAYNAME
</pre>


<p>
   Y, M and D are digits.  DAYNAME can contain any non
   whitespace-character besides <code>+</code>, <code>-</code>, <code>]</code>, <code>&gt;</code>, a digit or <code>\n</code>.
</p>
<p>
   TIME follows the pattern =H:MM~.  H can be one or two digit long
   and can start with 0.
</p>
<p>
   REPEATER follows the patter:
</p>



<pre class="example">MARK VALUE UNIT
</pre>


<p>
   MARK is <code>+</code> (cumulate type), <code>++</code> (catch-up type) or <code>.+</code> (restart
   type).
</p>
<p>
   VALUE is a number.
</p>
<p>
   UNIT is a character among <code>h</code> (hour), <code>d</code> (day), <code>w</code> (week), <code>m</code>
   (month), <code>y</code> (year).
</p>
<p>
   MARK, VALUE and UNIT are not separated by whitespace characters.
</p>
</div>

</div>

<div id="outline-container-Emphasis_Markers" class="outline-3">
<h3 id="Emphasis_Markers"><a name="sec-6-13" id="sec-6-13"></a><span class="section-number-3">6.13</span> Text Markup</h3>
<div class="outline-text-3" id="text-Emphasis_Markers">


<p>
   Text markup follows the pattern:
</p>



<pre class="example">PRE MARKER CONTENTS MARKER POST
</pre>


<p>
   PRE is a whitespace character, <code>(</code>, <code>{</code> ~'~ or a double quote.  It
   can also be a beginning of line.
</p>
<p>
   MARKER is a character among <code>*</code> (bold), <code>=</code> (verbatim), <code>/</code>
   (italic), <code>+</code> (strike-through), <code>_</code> (underline), ~~~ (code).
</p>
<p>
   <a href="#CONTENTS">CONTENTS</a> is a string following the pattern:
</p>



<pre class="example">BORDER BODY BORDER
</pre>


<p>
   BORDER can be any non-whitespace character excepted ~,~, ~'~ or
   a double quote.
</p>
<p>
   BODY can contain contain any character but may not span over more
   than 3 lines.
</p>
<p>
   BORDER and BODY are not separated by whitespaces.
</p>
<p>
   <a href="#CONTENTS">CONTENTS</a> can contain any object encountered in a paragraph when
   markup is "bold", "italic", "strike-through" or "underline".
</p>
<p>
   POST is a whitespace character, <code>-</code>, <code>.</code>, ~,~, <code>:</code>, <code>!</code>, <code>?</code>, ~'~,
   <code>)</code>, <code>}</code> or a double quote.  It can also be an end of line.
</p>
<p>
   PRE, MARKER, <a href="#CONTENTS">CONTENTS</a>, MARKER and POST are not separated by
   whitespace characters.
</p>

<hr/>

<blockquote>

<p>All of this is wrong if <code>org-emphasis-regexp-components</code> or
<code>org-emphasis-alist</code> are modified.
</p>
<p>
This should really be simplified and made persistent (i.e. no
defcustom allowed).  Otherwise, portability and parsing are
jokes.
</p>
<p>
Also, <a href="#CONTENTS">CONTENTS</a> should be anything within code and verbatim
emphasis, by definition.  &mdash; ngz
</p>
</blockquote>


</div>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><a name="ID-d81fd9ba-e47a-461a-8a22-a3b0eb01f58e" id="ID-d81fd9ba-e47a-461a-8a22-a3b0eb01f58e"></a><span class="section-number-2">7</span> Appendix</h2>
<div class="outline-text-2" id="text-7">





<pre class="example">(defpackage :smug/parser/org
  (:use :cl :smug/pure/dot)
  (:export #:.affiliated-keyword
           #:.element-block
           #:.line))
(in-package :smug/parser/org)

(defvar *org-parameters* (list))

(defun make-org-parameter (name value &amp;optional documentation)
  (setf *org-parameters* (acons (cons name documentation) value *org-parameters*)))

(defun org-parameter (name)
  (cdr (assoc name *org-parameters* :key #'car)))

(defun .optional (parser)
  (.maybe parser (.result nil)))

(defun .separator ()
  (.or (.is #'char= #\Space) 
       (.progn (.not (.item))
               (.result :end))
       (.progn (.not (.is-not #'char= #\Newline))
               (.result #\Newline))))

(defun .make (function &amp;rest plist)
  (if (and function (not plist))
      (.result (funcall function))
      (destructuring-bind (name value . rest) plist
        (.let* ((value value)
                (rest (if rest 
                          (apply #'.make nil rest)
                          (.result nil))))
          (.result (if function 
                       (apply function name value rest)
                       (list* name value rest)))))))

(defun .make-instance (name &amp;rest initargs)
 (apply #'.make (lambda (&amp;rest initargs)
         (apply #'make-instance name initargs))
        initargs))

(defclass syntax () ())

(defmethod print-object ((object syntax) stream)
  (print-unreadable-object (object stream :type t :identity nil)
    (let ((class (class-of object)))
      (dolist (slotd (c2mop:class-slots class))
        (format stream "~%    ~S: ~S" (c2mop:slot-definition-name slotd)
                (handler-case (c2mop:slot-value-using-class class object slotd)
                  (unbound-slot () '|#&lt;unbound&gt;| )))))))    

(defvar *whitespace* '(#\Space #\Tab)) 

(defun .whitespace ()
  (.is 'member *whitespace*))

(defclass whitespace (syntax)
  ((whitespace-prefix :initarg :whitespace-prefix
        :accessor whitespace-prefix)
   (whitespace-postfix :initarg :whitespace-postfix
         :accessor whitespace-postfix)))  

(defun .line (&amp;optional (nl #\Newline))
  (.prog1 (.coerce (.some (.is-not #'char= nl)) 
                   'cl:string)
          (.is #'char= nl)))

(defstruct until 
  contents end)

(defun .until (parser &amp;key (do (.item)) contents)
  (.let* ((until (.or parser (.result nil))))
    (if until 
        (.result (make-until :contents (reverse contents)
                             :end until))
        (.let* ((first do))
          (.until parser :do do :contents (list* first contents))))))


(defclass |keyword| (whitespace)
  ((name :initarg :name
         :accessor keyword-name)
   (value :initarg :value
          :accessor keyword-value)))

(defun .keyword ()
  (.make-instance 
   '|keyword|
   :whitespace-prefix (.some (.whitespace))
   :name (.coerce 
          (.progn          
           (.string= "#+")
           (.every (.is-not 'member '(#\Newline #\:))))
          'cl:string)
   :value (.progn 
           (.string= ": ")
           (.line))))

(defun |keywordp| (thing)
  (typep thing '|keyword|))


(defclass greater-element (whitespace)
  ((keywords :initarg :keywords 
             :accessor greater-element-keywords)))

(defun .greater-element (.parser)
  (.let* ((keys (.some (.keyword)))
          (pre (.some (.whitespace)))
          (element .parser))
    (setf (greater-element-keywords element) keys
          (whitespace-prefix element) pre)
    (.result element)))              

(defclass greater-block (greater-element)
  ((name :initarg :name
         :accessor greater-block-name)
   (parameters :initarg :parameters
         :accessor greater-block-parameters)
   (contents :initarg :contents
         :accessor greater-block-contents)))


(defvar *greater-block-classes* (list))

(defun greater-block-classes ()
  *greater-block-classes*)

(defun (setf greater-block-classes) (value)
  (setf *greater-block-classes* value))

(defun add-greater-block (name class)
  (push  (cons name class)
         (greater-block-classes)))

(defun make-greater-block-instance (name &amp;rest initargs)
  (apply #'make-instance 
    (destructuring-bind (_ . maker)
        (or (assoc name (greater-block-classes) 
                   :test #'string-equal)
            (assoc nil (greater-block-classes)))
      (declare (ignore _))
      maker)            
    initargs))





(defun .greater-block ()
  (flet ((.end-block (name)
           (.progn (.some (.whitespace))
                   (.string-equal 
                    (concatenate 'string
                                 "#+END_" name)))))

    (.let* ((keywords (.some (.keyword)))
            (_ (.string-equal "#+BEGIN_"))
            (name 
             (.coerce 
              (.every (.is-not 'member (cons #\Newline *whitespace*)))
              'cl:string))
            (parameters
             (.progn (.whitespace) (.line)))
            (contents (.until (.end-block name) 
                              :do (.line))))
      (.result (make-greater-block-instance 
                name
                :keywords keywords
                :name name
                :parameters parameters
                :contents (until-contents 
                           contents))))))


(defclass special-block (greater-block) ())
(add-greater-block nil 'special-block)  

(defclass element-block (greater-block) 
 ((name :accessor element-block-name)
  (parameters :initarg :parameters
              :accessor element-block-data)
  (contents :initarg :contents
            :accessor element-block-contents)))

(defclass comment-block (element-block) ())
(add-greater-block "COMMENT" 'comment-block)

(defclass example-block (element-block) ())
(add-greater-block "EXAMPLE" 'example-block)

(defclass verse-block (element-block) ())
(add-greater-block "VERSE" 'verse-block)  

(defclass source-block (element-block) 
  ((language :initarg :language 
            :accessor source-block-language)
   (switches :initarg :switches 
             :accessor source-block-switches)
   (arguments :initarg :arguments 
              :accessor source-block-arguments))    )     
(add-greater-block "SRC" 'source-block)






(defmethod initialize-instance :after ((source-block source-block)
                                       &amp;rest initargs)
  (declare (ignore initargs))
  (flet ((.data ()
           (.let* ((language 
                    (.every (.is-not 'member (cons #\Newline *whitespace*))) )
                   (switches (.result nil))
                   (_ (.optional (.is 'eql #\Space)))
                   (arguments 
                    (.optional (.every (.is-not 'eql #\Newline)))))
             (with-accessors ((l source-block-language)
                              (s source-block-switches)
                              (a source-block-arguments)) 
                 source-block
               (.result (setf l (coerce language 'cl:string)
                              s switches
                              a (coerce arguments 'cl:string)))))))
    (.run (.data) (element-block-data source-block))))


(defparameter |*TEST-STRING:headline*|
  (subseq "
* 

** DONE

*** Some e-mail

**** TODO [#A] COMMENT Title :tag:a2%: "
         1))
</pre>


<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn-Headlines_and_Sections.1" href="#fnr-Headlines_and_Sections.1">1</a></sup> In particular, the parser requires stars at column 0 to be
quoted by a comma when they do not define a headline.
</p>


<p class="footnote"><sup><a class="footnum" name="fn-Headlines_and_Sections.2" href="#fnr-Headlines_and_Sections.2">2</a></sup> It also means that only headlines and sections can be
recognized just by looking at the beginning of the line.
</p></div>
</div>

</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2014-03-08T13:58-0800</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
